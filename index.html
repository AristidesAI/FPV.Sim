<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FPV Racing Simulator - Betaflight Actual Rates</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #2196F3;
            --accent: #FFC107;
            --bg-light: #f5f5f5;
            --surface-light: #ffffff;
            --text-light: #333333;
            --bg-dark: #121212;
            --surface-dark: #1e1e1e;
            --text-dark: #e0e0e0;
            --border-radius: 12px;
        }

        body {
            margin: 0;
            font-family: 'Roboto', sans-serif;
            overflow: hidden;
            display: flex;
            height: 100vh;
            background-color: var(--bg-light);
            color: var(--text-light);
            transition: background-color 0.3s, color 0.3s;
        }

        body.dark-mode {
            background-color: var(--bg-dark);
            color: var(--text-dark);
        }

        /* --- SIDEBAR --- */
        #sidebar {
            width: 340px;
            padding: 20px;
            background-color: var(--surface-light);
            box-shadow: 2px 0 10px rgba(0,0,0,0.05);
            display: flex;
            flex-direction: column;
            gap: 15px;
            z-index: 20;
            overflow-y: auto;
            transition: background-color 0.3s;
        }

        body.dark-mode #sidebar { background-color: var(--surface-dark); }

        h2 { margin: 0; font-weight: 700; font-size: 1.5rem; }
        h3 { margin: 0 0 8px 0; font-size: 0.85rem; text-transform: uppercase; color: var(--primary); letter-spacing: 0.5px; }

        .control-group {
            background: rgba(0,0,0,0.04);
            padding: 12px;
            border-radius: var(--border-radius);
        }
        body.dark-mode .control-group { background: rgba(255,255,255,0.05); }

        .input-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        .input-row label { font-size: 0.8rem; flex: 1; }
        .input-row input {
            width: 70px;
            padding: 6px;
            border: 1px solid #ccc;
            border-radius: 6px;
            background: transparent;
            color: inherit;
            text-align: right;
        }

        /* --- BUTTONS --- */
        button {
            padding: 12px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: 0.2s;
            width: 100%;
            margin-bottom: 5px;
        }
        button:hover { filter: brightness(1.1); }
        
        .btn-primary { background-color: var(--primary); color: white; }
        .btn-secondary { background-color: #607D8B; color: white; }
        .btn-accent { background-color: var(--accent); color: #333; }

        /* --- CANVAS --- */
        #canvas-container {
            flex-grow: 1;
            position: relative;
            background: radial-gradient(circle at center, #e0e0e0 0%, #bdbdbd 100%);
        }
        body.dark-mode #canvas-container {
            background: radial-gradient(circle at center, #2c2c2c 0%, #000000 100%);
        }

        /* --- MAPPING MODAL --- */
        #mapping-modal {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6);
            z-index: 100;
            display: none; /* Hidden by default */
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(4px);
        }
        .modal-content {
            background: var(--surface-light);
            padding: 25px;
            border-radius: 16px;
            width: 450px;
            max-width: 90%;
            color: var(--text-light);
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
        }
        body.dark-mode .modal-content {
            background: var(--surface-dark);
            color: var(--text-dark);
        }
        
        .map-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(0,0,0,0.1);
        }
        body.dark-mode .map-row { border-bottom: 1px solid rgba(255,255,255,0.1); }
        
        .map-label { width: 60px; font-weight: bold; }
        .map-select { flex: 1; padding: 8px; border-radius: 6px; }
        .map-invert { display: flex; align-items: center; gap: 5px; font-size: 0.8rem; }
        .axis-viz {
            width: 100px;
            height: 10px;
            background: #ddd;
            border-radius: 5px;
            position: relative;
            overflow: hidden;
        }
        .axis-bar {
            position: absolute;
            top: 0; left: 50%;
            height: 100%;
            width: 0%; /* Dynamic */
            background: var(--primary);
            transition: width 0.05s, left 0.05s;
        }

        /* --- NOTIFICATIONS --- */
        #notification-area {
            position: absolute;
            top: 20px; right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 200;
        }
        .toast {
            background-color: var(--surface-light);
            color: var(--text-light);
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            border-left: 5px solid var(--primary);
            animation: slideIn 0.3s ease-out;
        }
        body.dark-mode .toast { background-color: var(--surface-dark); color: var(--text-dark); }
        @keyframes slideIn { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }

        /* --- HUD OVERLAY --- */
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            font-family: 'Roboto Mono', monospace;
            font-size: 14px;
            color: white;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.8);
            pointer-events: none;
            z-index: 50;
        }
        .hud-row {
            margin-bottom: 5px;
            display: flex;
            gap: 15px;
        }
        .hud-label { opacity: 0.7; }
        .hud-value { font-weight: bold; min-width: 60px; }

        /* --- CRASH OVERLAY --- */
        #crash-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(180, 0, 0, 0.6);
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 80;
            backdrop-filter: blur(3px);
        }
        #crash-overlay h1 {
            font-size: 4rem;
            color: white;
            margin: 0;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.5);
        }
        #crash-overlay p {
            font-size: 1.2rem;
            color: white;
            opacity: 0.9;
        }

        /* --- COUNTDOWN OVERLAY --- */
        #countdown-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 75;
            pointer-events: none;
        }
        #countdown-text {
            font-size: 8rem;
            font-weight: bold;
            color: white;
            text-shadow: 4px 4px 10px rgba(0,0,0,0.7);
        }

        /* --- RACE INFO --- */
        #race-info {
            position: absolute;
            top: 20px;
            right: 380px;
            background: rgba(0,0,0,0.6);
            padding: 15px 20px;
            border-radius: 10px;
            color: white;
            font-family: 'Roboto Mono', monospace;
            z-index: 50;
            display: none;
        }
        #race-info .time { font-size: 2rem; font-weight: bold; }
        #race-info .lap-info { font-size: 0.9rem; opacity: 0.8; margin-top: 5px; }
        #race-info .gate-info { font-size: 1rem; margin-top: 8px; color: #4CAF50; }

        /* --- MODE BUTTONS --- */
        .mode-btn-group {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }
        .mode-btn {
            flex: 1;
            padding: 10px;
            font-size: 0.85rem;
        }
        .mode-btn.active {
            background-color: var(--accent) !important;
            color: #333 !important;
        }

        /* --- KEYBOARD HINTS --- */
        .key-hints {
            font-size: 0.75rem;
            opacity: 0.6;
            margin-top: 10px;
            line-height: 1.6;
        }
        .key {
            background: rgba(255,255,255,0.2);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
        }

    </style>
</head>
<body>

    <div id="sidebar">
        <div>
            <h2>FPV Racing Sim</h2>
            <p style="font-size: 0.8rem; opacity: 0.7; margin-top:5px;">Betaflight Actual Rates</p>
        </div>

        <div class="control-group">
            <h3>Game Mode</h3>
            <div class="mode-btn-group">
                <button id="mode-freefly" class="btn-secondary mode-btn active">Free Flight</button>
                <button id="mode-race" class="btn-secondary mode-btn">Race</button>
            </div>
            <div class="key-hints">
                <span class="key">R</span> Reset &nbsp;
                <span class="key">Space</span> Start Race<br>
                <span class="key">Esc</span> Free Flight<br>
                <span class="key">W</span>/<span class="key">S</span> Camera Tilt
            </div>
        </div>

        <button id="open-mapping" class="btn-accent">Configure Controller</button>

        <div class="control-group">
            <h3>Roll</h3>
            <div class="input-row"><label>Center Sens</label><input type="number" id="roll-center" value="70"></div>
            <div class="input-row"><label>Max Rate</label><input type="number" id="roll-max" value="670"></div>
            <div class="input-row"><label>Expo</label><input type="number" id="roll-expo" value="0.55" step="0.01"></div>
        </div>

        <div class="control-group">
            <h3>Pitch</h3>
            <div class="input-row"><label>Center Sens</label><input type="number" id="pitch-center" value="70"></div>
            <div class="input-row"><label>Max Rate</label><input type="number" id="pitch-max" value="670"></div>
            <div class="input-row"><label>Expo</label><input type="number" id="pitch-expo" value="0.55" step="0.01"></div>
        </div>

        <div class="control-group">
            <h3>Yaw</h3>
            <div class="input-row"><label>Center Sens</label><input type="number" id="yaw-center" value="70"></div>
            <div class="input-row"><label>Max Rate</label><input type="number" id="yaw-max" value="670"></div>
            <div class="input-row"><label>Expo</label><input type="number" id="yaw-expo" value="0.55" step="0.01"></div>
        </div>

        <div style="margin-top: auto;">
            <button id="reset-cam" class="btn-secondary">Reset View</button>
            <button id="theme-toggle" class="btn-primary">Toggle Dark Mode</button>
        </div>
    </div>

    <div id="canvas-container">
        <!-- HUD Overlay -->
        <div id="hud">
            <div class="hud-row">
                <span class="hud-label">Speed:</span>
                <span class="hud-value" id="hud-speed">0</span>
                <span>m/s</span>
            </div>
            <div class="hud-row">
                <span class="hud-label">Alt:</span>
                <span class="hud-value" id="hud-alt">0</span>
                <span>m</span>
            </div>
            <div class="hud-row">
                <span class="hud-label">Throttle:</span>
                <span class="hud-value" id="hud-throttle">0</span>
                <span>%</span>
            </div>
            <div class="hud-row">
                <span class="hud-label">Cam Tilt:</span>
                <span class="hud-value" id="hud-tilt">15</span>
                <span>Â°</span>
            </div>
        </div>

        <!-- Race Info Panel -->
        <div id="race-info">
            <div class="time" id="race-time">00:00.000</div>
            <div class="lap-info">Best: <span id="best-lap">--:--</span></div>
            <div class="gate-info" id="gate-counter">Gate 0 / 0</div>
        </div>

        <!-- Crash Overlay -->
        <div id="crash-overlay">
            <h1>CRASHED!</h1>
            <p>Press <strong>R</strong> to reset</p>
        </div>

        <!-- Countdown Overlay -->
        <div id="countdown-overlay">
            <div id="countdown-text">3</div>
        </div>
    </div>

    <div id="notification-area"></div>

    <div id="mapping-modal">
        <div class="modal-content">
            <h2 style="margin-bottom: 20px;">Controller Mapping</h2>
            <p style="font-size: 0.9rem; margin-bottom: 20px; opacity: 0.8;">
                Move your sticks to identify axes. Assign them to the correct functions.
            </p>

            <div id="mapping-rows"></div>

            <button id="close-mapping" class="btn-primary" style="margin-top: 20px;">Save & Close</button>
        </div>
    </div>

    <script>
        // ============================================================
        // FPV RACING SIMULATOR - BETAFLIGHT ACTUAL RATES
        // ============================================================

        // --- 1. STATE & CONFIGURATION ---
        let config = {
            mapping: {
                roll: { axis: 2, invert: false },
                pitch: { axis: 3, invert: false },
                yaw: { axis: 0, invert: true },
                throttle: { axis: 1, invert: true }
            }
        };

        // Load saved config
        const savedConfig = localStorage.getItem('bf_rate_config');
        if (savedConfig) {
            try {
                const parsed = JSON.parse(savedConfig);
                if (parsed.mapping) config.mapping = parsed.mapping;
            } catch(e) { console.log('Config load error'); }
        }

        function saveConfig() {
            localStorage.setItem('bf_rate_config', JSON.stringify(config));
        }

        // --- 2. PHYSICS STATE ---
        const physics = {
            position: new THREE.Vector3(0, 5, -120),
            velocity: new THREE.Vector3(0, 0, 0),
            gravity: 9.81,
            dragCoeff: 0.4,       // Air resistance
            maxThrust: 30,        // Max thrust force (gives good power-to-weight)
            crashed: false,
            droneRadius: 0.5
        };

        const spawnPoint = new THREE.Vector3(0, 5, -120);  // Start in open area south of city

        // Thrust works like real acro:
        // - Thrust vector points "up" from the drone's perspective
        // - Pitch forward = thrust tilts forward = drone accelerates forward
        // - At hover, ~40% throttle counters gravity

        // --- 3. GAME STATE ---
        const gameState = {
            mode: 'freefly',        // 'freefly' | 'countdown' | 'racing' | 'crashed'
            raceStartTime: 0,
            currentLapTime: 0,
            currentGate: 0,
            totalGates: 0,
            lapTimes: [],
            bestLap: null
        };

        // Load best lap from localStorage
        const savedBestLap = localStorage.getItem('fpv_best_lap');
        if (savedBestLap) gameState.bestLap = parseFloat(savedBestLap);

        // --- 4. CAMERA CONTROLLER ---
        const cameraController = {
            offset: new THREE.Vector3(0, 0.12, 0.35),  // Front of drone, between front props
            tiltAngle: 15,      // Camera tilt in degrees (positive = tilted up)
            minTilt: -10,       // Min tilt (looking down)
            maxTilt: 45,        // Max tilt (looking up, for fast forward flight)
        };

        // --- 5. THEME & UI ---
        const body = document.body;
        const themeBtn = document.getElementById('theme-toggle');

        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            body.classList.add('dark-mode');
        }
        themeBtn.addEventListener('click', () => body.classList.toggle('dark-mode'));

        function showNotification(msg) {
            const area = document.getElementById('notification-area');
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.innerText = msg;
            area.appendChild(toast);
            setTimeout(() => { toast.style.opacity = '0'; setTimeout(() => toast.remove(), 300); }, 3000);
        }

        // --- 6. THREE.JS SCENE SETUP ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();

        // Create sky dome for static background
        const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
        const skyCanvas = document.createElement('canvas');
        skyCanvas.width = 1024;
        skyCanvas.height = 1024;
        const skyCtx = skyCanvas.getContext('2d');

        // Gradient from top to bottom
        const skyGradient = skyCtx.createLinearGradient(0, 0, 0, 1024);
        skyGradient.addColorStop(0, '#1565C0');      // Deep blue at top
        skyGradient.addColorStop(0.15, '#1976D2');   // Royal blue
        skyGradient.addColorStop(0.3, '#42A5F5');    // Light blue
        skyGradient.addColorStop(0.5, '#64B5F6');    // Sky blue
        skyGradient.addColorStop(0.7, '#90CAF9');    // Powder blue
        skyGradient.addColorStop(0.85, '#BBDEFB');   // Very light blue
        skyGradient.addColorStop(1, '#E3F2FD');      // Almost white at horizon
        skyCtx.fillStyle = skyGradient;
        skyCtx.fillRect(0, 0, 1024, 1024);

        const skyTexture = new THREE.CanvasTexture(skyCanvas);
        const skyMaterial = new THREE.MeshBasicMaterial({
            map: skyTexture,
            side: THREE.BackSide
        });
        const skyDome = new THREE.Mesh(skyGeometry, skyMaterial);
        scene.add(skyDome);

        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0xBBDEFB, 150, 500);

        const camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
        camera.position.set(0, 5, -120);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        container.appendChild(renderer.domElement);

        // Lighting - Ambient
        const ambientLight = new THREE.AmbientLight(0x87CEEB, 0.4);
        scene.add(ambientLight);

        // Hemisphere light for natural sky/ground lighting
        const hemiLight = new THREE.HemisphereLight(0x87CEEB, 0x3d8c40, 0.3);
        scene.add(hemiLight);

        // Sun light (directional)
        const sunLight = new THREE.DirectionalLight(0xfffaf0, 1.2);
        sunLight.position.set(100, 150, 80);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 4096;
        sunLight.shadow.mapSize.height = 4096;
        sunLight.shadow.camera.near = 10;
        sunLight.shadow.camera.far = 500;
        sunLight.shadow.camera.left = -150;
        sunLight.shadow.camera.right = 150;
        sunLight.shadow.camera.top = 150;
        sunLight.shadow.camera.bottom = -150;
        scene.add(sunLight);

        // Visible Sun sphere
        const sunGeom = new THREE.SphereGeometry(15, 32, 32);
        const sunMat = new THREE.MeshBasicMaterial({
            color: 0xffff80,
            transparent: true,
            opacity: 0.95
        });
        const sunMesh = new THREE.Mesh(sunGeom, sunMat);
        sunMesh.position.set(100, 150, 80);
        scene.add(sunMesh);

        // Sun glow
        const sunGlowGeom = new THREE.SphereGeometry(25, 32, 32);
        const sunGlowMat = new THREE.MeshBasicMaterial({
            color: 0xffffcc,
            transparent: true,
            opacity: 0.3
        });
        const sunGlow = new THREE.Mesh(sunGlowGeom, sunGlowMat);
        sunGlow.position.copy(sunMesh.position);
        scene.add(sunGlow);

        // --- 7. GROUND PLANE WITH GRASS TEXTURE ---
        const groundSize = 400;

        // Create procedural grass texture
        const grassCanvas = document.createElement('canvas');
        grassCanvas.width = 512;
        grassCanvas.height = 512;
        const grassCtx = grassCanvas.getContext('2d');

        // Base green
        grassCtx.fillStyle = '#3a7d32';
        grassCtx.fillRect(0, 0, 512, 512);

        // Add grass variation
        for (let i = 0; i < 10000; i++) {
            const x = Math.random() * 512;
            const y = Math.random() * 512;
            const shade = Math.random() * 50 - 25;
            const g = Math.floor(125 + shade);
            grassCtx.fillStyle = `rgb(${45 + Math.random() * 25}, ${g}, ${35 + Math.random() * 25})`;
            grassCtx.fillRect(x, y, 1 + Math.random() * 3, 1 + Math.random() * 3);
        }

        // Add some darker patches
        for (let i = 0; i < 80; i++) {
            const x = Math.random() * 512;
            const y = Math.random() * 512;
            grassCtx.fillStyle = 'rgba(30, 80, 30, 0.25)';
            grassCtx.beginPath();
            grassCtx.arc(x, y, 8 + Math.random() * 25, 0, Math.PI * 2);
            grassCtx.fill();
        }

        const grassTexture = new THREE.CanvasTexture(grassCanvas);
        grassTexture.wrapS = THREE.RepeatWrapping;
        grassTexture.wrapT = THREE.RepeatWrapping;
        grassTexture.repeat.set(60, 60);

        const groundGeom = new THREE.PlaneGeometry(groundSize, groundSize);
        const groundMat = new THREE.MeshStandardMaterial({
            map: grassTexture,
            roughness: 0.85
        });
        const ground = new THREE.Mesh(groundGeom, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = 0;
        ground.receiveShadow = true;
        scene.add(ground);

        // --- 7b. 3D GRASS BLADES AND GRASS CLUMPS ---
        const grassBladeMaterials = [
            new THREE.MeshStandardMaterial({ color: 0x3a7d32, side: THREE.DoubleSide }),
            new THREE.MeshStandardMaterial({ color: 0x4a8d42, side: THREE.DoubleSide }),
            new THREE.MeshStandardMaterial({ color: 0x2d6b27, side: THREE.DoubleSide }),
            new THREE.MeshStandardMaterial({ color: 0x5a9d52, side: THREE.DoubleSide }),
            new THREE.MeshStandardMaterial({ color: 0x3d8b35, side: THREE.DoubleSide }),
            new THREE.MeshStandardMaterial({ color: 0x4d9d45, side: THREE.DoubleSide })
        ];

        // Create grass clumps (groups of blades)
        function createGrassClump(x, z, density = 5) {
            const clumpGroup = new THREE.Group();
            for (let i = 0; i < density; i++) {
                const bladeHeight = 0.3 + Math.random() * 0.5;
                const bladeGeom = new THREE.PlaneGeometry(0.08 + Math.random() * 0.06, bladeHeight);
                const blade = new THREE.Mesh(
                    bladeGeom,
                    grassBladeMaterials[Math.floor(Math.random() * grassBladeMaterials.length)]
                );
                blade.position.set(
                    (Math.random() - 0.5) * 0.5,
                    bladeHeight / 2,
                    (Math.random() - 0.5) * 0.5
                );
                blade.rotation.y = Math.random() * Math.PI;
                blade.rotation.x = -0.15 + Math.random() * 0.3;
                clumpGroup.add(blade);
            }
            clumpGroup.position.set(x, 0, z);
            scene.add(clumpGroup);
        }

        // Dense grass everywhere except city center and streets
        for (let i = 0; i < 8000; i++) {
            const x = (Math.random() - 0.5) * groundSize * 0.95;
            const z = (Math.random() - 0.5) * groundSize * 0.95;

            // Skip city center
            if (Math.abs(x) < 85 && Math.abs(z) < 85) continue;
            // Skip train track area
            if (z > 85 && z < 95) continue;

            const density = 3 + Math.floor(Math.random() * 5);
            createGrassClump(x, z, density);
        }

        // Extra dense grass near spawn area
        for (let i = 0; i < 2000; i++) {
            const x = (Math.random() - 0.5) * 60;
            const z = -120 + (Math.random() - 0.5) * 40;
            createGrassClump(x, z, 4 + Math.floor(Math.random() * 4));
        }

        // Tall grass / wild grass patches
        const tallGrassMat = new THREE.MeshStandardMaterial({ color: 0x6b8e23, side: THREE.DoubleSide });
        for (let i = 0; i < 500; i++) {
            const x = (Math.random() - 0.5) * groundSize * 0.9;
            const z = (Math.random() - 0.5) * groundSize * 0.9;
            if (Math.abs(x) < 90 && Math.abs(z) < 90) continue;

            const tallGrass = new THREE.Mesh(
                new THREE.PlaneGeometry(0.15, 0.8 + Math.random() * 0.4),
                tallGrassMat
            );
            tallGrass.position.set(x, 0.4, z);
            tallGrass.rotation.y = Math.random() * Math.PI;
            tallGrass.rotation.x = Math.random() * 0.2;
            scene.add(tallGrass);
        }

        // --- 8. DRONE MODEL ---
        const droneGroup = new THREE.Group();
        const propellers = [];

        // Body
        const matBody = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.4, metalness: 0.6 });
        const matArm = new THREE.MeshStandardMaterial({ color: 0x2196F3, roughness: 0.5, metalness: 0.3 });
        const matProp = new THREE.MeshStandardMaterial({ color: 0xdddddd, transparent: true, opacity: 0.6 });

        const bodyMesh = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.15, 0.3), matBody);
        bodyMesh.castShadow = true;
        droneGroup.add(bodyMesh);

        // Arms (X shape)
        const arm1 = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.05, 1.8), matArm);
        arm1.rotation.y = Math.PI / 4;
        arm1.castShadow = true;
        const arm2 = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.05, 1.8), matArm);
        arm2.rotation.y = -Math.PI / 4;
        arm2.castShadow = true;
        droneGroup.add(arm1);
        droneGroup.add(arm2);

        // Propellers
        const propPositions = [
            { x: -0.6, z: 0.6 }, { x: 0.6, z: -0.6 },
            { x: 0.6, z: 0.6 }, { x: -0.6, z: -0.6 }
        ];
        propPositions.forEach((pos, i) => {
            const prop = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.35, 0.02, 16), matProp);
            prop.position.set(pos.x, 0.08, pos.z);
            propellers.push(prop);
            droneGroup.add(prop);
        });

        droneGroup.position.copy(physics.position);
        scene.add(droneGroup);

        // --- 9. GATES REMOVED - FREE FLIGHT MODE ---
        const gates = [];  // Empty for compatibility

        // --- 10. CITY AND ENVIRONMENT ---
        const buildings = [];
        const trees = [];

        // Building materials
        const buildingMaterials = [
            new THREE.MeshStandardMaterial({ color: 0x808080, roughness: 0.7 }),
            new THREE.MeshStandardMaterial({ color: 0x606060, roughness: 0.6 }),
            new THREE.MeshStandardMaterial({ color: 0x505050, roughness: 0.8 }),
            new THREE.MeshStandardMaterial({ color: 0x707070, roughness: 0.5 }),
            new THREE.MeshStandardMaterial({ color: 0x8a8a8a, roughness: 0.6 }),
            new THREE.MeshStandardMaterial({ color: 0x4a5568, roughness: 0.7 }), // Blue-gray
            new THREE.MeshStandardMaterial({ color: 0x718096, roughness: 0.5 }), // Slate
        ];
        const glassMat = new THREE.MeshStandardMaterial({ color: 0x88ccff, roughness: 0.1, metalness: 0.9 });
        const roofMat = new THREE.MeshStandardMaterial({ color: 0x3a3a3a, roughness: 0.9 });

        // Create a building
        function createBuilding(x, z, width, depth, height, hasWindows = true) {
            const buildingGroup = new THREE.Group();
            const mat = buildingMaterials[Math.floor(Math.random() * buildingMaterials.length)];

            // Main structure
            const building = new THREE.Mesh(new THREE.BoxGeometry(width, height, depth), mat);
            building.position.y = height / 2;
            building.castShadow = true;
            building.receiveShadow = true;
            buildingGroup.add(building);

            // Windows
            if (hasWindows && height > 10) {
                const windowRows = Math.floor(height / 4);
                const windowCols = Math.floor(width / 3);
                for (let row = 0; row < windowRows; row++) {
                    for (let col = 0; col < windowCols; col++) {
                        const windowMesh = new THREE.Mesh(
                            new THREE.PlaneGeometry(1.5, 2),
                            glassMat
                        );
                        windowMesh.position.set(
                            -width/2 + 2 + col * 3,
                            3 + row * 4,
                            depth/2 + 0.05
                        );
                        buildingGroup.add(windowMesh);

                        // Back windows
                        const backWindow = windowMesh.clone();
                        backWindow.position.z = -depth/2 - 0.05;
                        backWindow.rotation.y = Math.PI;
                        buildingGroup.add(backWindow);
                    }
                }
            }

            // Roof details
            if (Math.random() > 0.5) {
                const roofBox = new THREE.Mesh(
                    new THREE.BoxGeometry(width * 0.3, 2, depth * 0.3),
                    roofMat
                );
                roofBox.position.y = height + 1;
                roofBox.castShadow = true;
                buildingGroup.add(roofBox);
            }

            buildingGroup.position.set(x, 0, z);
            scene.add(buildingGroup);

            return {
                position: new THREE.Vector3(x, 0, z),
                width: width,
                depth: depth,
                height: height
            };
        }

        // Create streets (dark gray planes)
        const streetMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.9 });
        const sidewalkMat = new THREE.MeshStandardMaterial({ color: 0x999999, roughness: 0.8 });

        // Main streets grid
        const streetWidth = 12;
        const blockSize = 40;

        // Horizontal streets
        for (let z = -60; z <= 60; z += blockSize) {
            const street = new THREE.Mesh(
                new THREE.PlaneGeometry(160, streetWidth),
                streetMat
            );
            street.rotation.x = -Math.PI / 2;
            street.position.set(0, 0.02, z);
            street.receiveShadow = true;
            scene.add(street);

            // Road markings
            for (let x = -75; x < 75; x += 10) {
                const marking = new THREE.Mesh(
                    new THREE.PlaneGeometry(5, 0.5),
                    new THREE.MeshStandardMaterial({ color: 0xffff00 })
                );
                marking.rotation.x = -Math.PI / 2;
                marking.position.set(x, 0.03, z);
                scene.add(marking);
            }
        }

        // Vertical streets
        for (let x = -60; x <= 60; x += blockSize) {
            const street = new THREE.Mesh(
                new THREE.PlaneGeometry(streetWidth, 160),
                streetMat
            );
            street.rotation.x = -Math.PI / 2;
            street.position.set(x, 0.02, 0);
            street.receiveShadow = true;
            scene.add(street);
        }

        // Create city blocks with buildings
        const blockPositions = [
            { x: -40, z: -40 }, { x: 0, z: -40 }, { x: 40, z: -40 },
            { x: -40, z: 0 }, { x: 40, z: 0 },
            { x: -40, z: 40 }, { x: 0, z: 40 }, { x: 40, z: 40 }
        ];

        blockPositions.forEach(block => {
            // Multiple buildings per block
            const numBuildings = 2 + Math.floor(Math.random() * 3);
            for (let i = 0; i < numBuildings; i++) {
                const offsetX = (Math.random() - 0.5) * 20;
                const offsetZ = (Math.random() - 0.5) * 20;
                const width = 8 + Math.random() * 12;
                const depth = 8 + Math.random() * 12;
                const height = 15 + Math.random() * 45;
                buildings.push(createBuilding(
                    block.x + offsetX,
                    block.z + offsetZ,
                    width, depth, height
                ));
            }
        });

        // Skyscrapers in center
        buildings.push(createBuilding(0, 0, 20, 20, 80));
        buildings.push(createBuilding(-25, 25, 15, 15, 60));
        buildings.push(createBuilding(25, -25, 18, 18, 70));

        // --- 10b. CARS ---
        const carColors = [0xff0000, 0x0000ff, 0x00ff00, 0xffff00, 0xffffff, 0x000000, 0xff8800];

        function createCar(x, z, rotation) {
            const carGroup = new THREE.Group();
            const color = carColors[Math.floor(Math.random() * carColors.length)];
            const carMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.3, metalness: 0.8 });

            // Body
            const body = new THREE.Mesh(new THREE.BoxGeometry(2, 0.8, 4), carMat);
            body.position.y = 0.6;
            body.castShadow = true;
            carGroup.add(body);

            // Cabin
            const cabin = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.7, 2), glassMat);
            cabin.position.y = 1.3;
            cabin.position.z = -0.3;
            carGroup.add(cabin);

            // Wheels
            const wheelGeom = new THREE.CylinderGeometry(0.35, 0.35, 0.3, 16);
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
            const wheelPositions = [
                { x: -1, z: 1.2 }, { x: 1, z: 1.2 },
                { x: -1, z: -1.2 }, { x: 1, z: -1.2 }
            ];
            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeom, wheelMat);
                wheel.rotation.z = Math.PI / 2;
                wheel.position.set(pos.x, 0.35, pos.z);
                carGroup.add(wheel);
            });

            carGroup.position.set(x, 0, z);
            carGroup.rotation.y = rotation;
            scene.add(carGroup);
        }

        // Place cars along streets
        for (let i = 0; i < 30; i++) {
            const streetZ = [-60, -20, 20, 60][Math.floor(Math.random() * 4)];
            const x = (Math.random() - 0.5) * 140;
            createCar(x, streetZ + (Math.random() - 0.5) * 4, Math.random() > 0.5 ? 0 : Math.PI);
        }

        // --- 10c. TRAIN AND TRACKS ---
        // Train tracks
        const trackMat = new THREE.MeshStandardMaterial({ color: 0x4a4a4a });
        const railMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.8 });

        const trackZ = 90;
        // Track bed
        const trackBed = new THREE.Mesh(new THREE.BoxGeometry(groundSize * 0.8, 0.5, 6), trackMat);
        trackBed.position.set(0, 0.25, trackZ);
        trackBed.receiveShadow = true;
        scene.add(trackBed);

        // Rails
        for (let offset of [-1.5, 1.5]) {
            const rail = new THREE.Mesh(new THREE.BoxGeometry(groundSize * 0.8, 0.2, 0.3), railMat);
            rail.position.set(0, 0.6, trackZ + offset);
            scene.add(rail);
        }

        // Train
        const trainGroup = new THREE.Group();
        const trainMat = new THREE.MeshStandardMaterial({ color: 0xcc0000, roughness: 0.5 });

        // Locomotive (rotated to face along X axis)
        const locomotive = new THREE.Mesh(new THREE.BoxGeometry(12, 4, 5), trainMat);
        locomotive.position.set(0, 2.5, 0);
        locomotive.castShadow = true;
        trainGroup.add(locomotive);

        // Train front
        const trainFront = new THREE.Mesh(new THREE.BoxGeometry(3, 3, 4), trainMat);
        trainFront.position.set(7, 2, 0);
        trainGroup.add(trainFront);

        // Carriages
        const carriageMat = new THREE.MeshStandardMaterial({ color: 0x2255aa });
        for (let i = 0; i < 4; i++) {
            const carriage = new THREE.Mesh(new THREE.BoxGeometry(10, 3.5, 4.5), carriageMat);
            carriage.position.set(-15 - i * 12, 2.3, 0);
            carriage.castShadow = true;
            trainGroup.add(carriage);
        }

        trainGroup.position.set(-100, 0.5, trackZ);
        scene.add(trainGroup);

        // Animate train
        let trainX = -100;
        function updateTrain(dt) {
            trainX += 15 * dt;
            if (trainX > groundSize / 2 + 50) trainX = -groundSize / 2 - 50;
            trainGroup.position.x = trainX;
        }

        // --- 10d. SAFETY CONES ---
        const coneMat = new THREE.MeshStandardMaterial({ color: 0xFF6600 });
        const coneStripeMat = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });

        function createSafetyCone(x, z) {
            const coneGroup = new THREE.Group();
            const cone = new THREE.Mesh(new THREE.ConeGeometry(0.4, 1.2, 8), coneMat);
            cone.position.y = 0.6;
            coneGroup.add(cone);

            // White stripes
            const stripe = new THREE.Mesh(new THREE.TorusGeometry(0.25, 0.05, 8, 16), coneStripeMat);
            stripe.rotation.x = Math.PI / 2;
            stripe.position.y = 0.8;
            coneGroup.add(stripe);

            // Base
            const base = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.1, 0.8), coneMat);
            base.position.y = 0.05;
            coneGroup.add(base);

            coneGroup.position.set(x, 0, z);
            scene.add(coneGroup);
        }

        // Place cones around construction areas and track
        for (let i = 0; i < 50; i++) {
            const x = (Math.random() - 0.5) * groundSize * 0.8;
            const z = (Math.random() - 0.5) * groundSize * 0.8;
            if (Math.abs(x) > 70 || Math.abs(z) > 70) {
                createSafetyCone(x, z);
            }
        }
        // Cones along track
        for (let x = -150; x <= 150; x += 20) {
            createSafetyCone(x, trackZ - 5);
            createSafetyCone(x, trackZ + 5);
        }

        // --- 10e. MANY DIFFERENT TREE TYPES ---
        const treeTrunkMat = new THREE.MeshStandardMaterial({ color: 0x4a3728 });
        const birchTrunkMat = new THREE.MeshStandardMaterial({ color: 0xe8e4d9 });
        const willowTrunkMat = new THREE.MeshStandardMaterial({ color: 0x5c4a32 });

        // Pine tree
        function createPineTree(x, z, scale = 1) {
            const treeGroup = new THREE.Group();
            const trunkHeight = 5 * scale;
            const trunk = new THREE.Mesh(
                new THREE.CylinderGeometry(0.3 * scale, 0.5 * scale, trunkHeight, 8),
                treeTrunkMat
            );
            trunk.position.y = trunkHeight / 2;
            trunk.castShadow = true;
            treeGroup.add(trunk);

            const foliageColors = [0x1a4d1a, 0x2d5a27, 0x1f5f1f];
            for (let i = 0; i < 5; i++) {
                const radius = (4 - i * 0.7) * scale;
                const foliage = new THREE.Mesh(
                    new THREE.ConeGeometry(radius, 3 * scale, 8),
                    new THREE.MeshStandardMaterial({ color: foliageColors[i % 3] })
                );
                foliage.position.y = trunkHeight - 1 + i * 1.5 * scale;
                foliage.castShadow = true;
                treeGroup.add(foliage);
            }
            treeGroup.position.set(x, 0, z);
            scene.add(treeGroup);
            return { position: new THREE.Vector3(x, 0, z), radius: 1.5 * scale, height: trunkHeight + 8 * scale };
        }

        // Oak tree (round foliage)
        function createOakTree(x, z, scale = 1) {
            const treeGroup = new THREE.Group();
            const trunkHeight = 4 * scale;
            const trunk = new THREE.Mesh(
                new THREE.CylinderGeometry(0.4 * scale, 0.6 * scale, trunkHeight, 8),
                treeTrunkMat
            );
            trunk.position.y = trunkHeight / 2;
            trunk.castShadow = true;
            treeGroup.add(trunk);

            const foliageMat = new THREE.MeshStandardMaterial({ color: 0x3a7d32 });
            for (let i = 0; i < 6; i++) {
                const foliage = new THREE.Mesh(
                    new THREE.SphereGeometry(2.5 * scale + Math.random(), 8, 6),
                    foliageMat
                );
                foliage.position.set(
                    (Math.random() - 0.5) * 3 * scale,
                    trunkHeight + 1 + Math.random() * 2 * scale,
                    (Math.random() - 0.5) * 3 * scale
                );
                foliage.castShadow = true;
                treeGroup.add(foliage);
            }
            treeGroup.position.set(x, 0, z);
            scene.add(treeGroup);
            return { position: new THREE.Vector3(x, 0, z), radius: 2 * scale, height: trunkHeight + 6 * scale };
        }

        // Palm tree
        function createPalmTree(x, z, scale = 1) {
            const treeGroup = new THREE.Group();
            const trunkHeight = 8 * scale;
            for (let i = 0; i < 8; i++) {
                const segment = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3 * scale, 0.35 * scale, trunkHeight / 8, 8),
                    new THREE.MeshStandardMaterial({ color: 0x8b7355 })
                );
                segment.position.y = i * trunkHeight / 8 + trunkHeight / 16;
                segment.position.x = Math.sin(i * 0.1) * 0.3;
                segment.castShadow = true;
                treeGroup.add(segment);
            }
            const frondMat = new THREE.MeshStandardMaterial({ color: 0x228b22, side: THREE.DoubleSide });
            for (let i = 0; i < 8; i++) {
                const frond = new THREE.Mesh(new THREE.PlaneGeometry(1 * scale, 5 * scale), frondMat);
                frond.position.y = trunkHeight;
                frond.rotation.y = (i / 8) * Math.PI * 2;
                frond.rotation.x = -0.8;
                treeGroup.add(frond);
            }
            treeGroup.position.set(x, 0, z);
            scene.add(treeGroup);
            return { position: new THREE.Vector3(x, 0, z), radius: 1 * scale, height: trunkHeight + 2 * scale };
        }

        // Birch tree (white bark, yellow-green leaves)
        function createBirchTree(x, z, scale = 1) {
            const treeGroup = new THREE.Group();
            const trunkHeight = 6 * scale;
            const trunk = new THREE.Mesh(
                new THREE.CylinderGeometry(0.2 * scale, 0.3 * scale, trunkHeight, 8),
                birchTrunkMat
            );
            trunk.position.y = trunkHeight / 2;
            trunk.castShadow = true;
            treeGroup.add(trunk);

            const foliageMat = new THREE.MeshStandardMaterial({ color: 0x90b050 });
            for (let i = 0; i < 4; i++) {
                const foliage = new THREE.Mesh(
                    new THREE.SphereGeometry(1.8 * scale + Math.random() * 0.5, 8, 6),
                    foliageMat
                );
                foliage.position.set(
                    (Math.random() - 0.5) * 2 * scale,
                    trunkHeight - 1 + i * 1.2 * scale,
                    (Math.random() - 0.5) * 2 * scale
                );
                foliage.castShadow = true;
                treeGroup.add(foliage);
            }
            treeGroup.position.set(x, 0, z);
            scene.add(treeGroup);
            return { position: new THREE.Vector3(x, 0, z), radius: 1.5 * scale, height: trunkHeight + 5 * scale };
        }

        // Willow tree (drooping branches)
        function createWillowTree(x, z, scale = 1) {
            const treeGroup = new THREE.Group();
            const trunkHeight = 5 * scale;
            const trunk = new THREE.Mesh(
                new THREE.CylinderGeometry(0.5 * scale, 0.7 * scale, trunkHeight, 8),
                willowTrunkMat
            );
            trunk.position.y = trunkHeight / 2;
            trunk.castShadow = true;
            treeGroup.add(trunk);

            // Drooping foliage
            const foliageMat = new THREE.MeshStandardMaterial({ color: 0x5a8a32, side: THREE.DoubleSide });
            for (let i = 0; i < 12; i++) {
                const droop = new THREE.Mesh(
                    new THREE.PlaneGeometry(0.5 * scale, 4 * scale),
                    foliageMat
                );
                const angle = (i / 12) * Math.PI * 2;
                droop.position.set(
                    Math.cos(angle) * 2 * scale,
                    trunkHeight - 1,
                    Math.sin(angle) * 2 * scale
                );
                droop.rotation.y = angle;
                droop.rotation.x = 0.5;
                treeGroup.add(droop);
            }
            // Top canopy
            const canopy = new THREE.Mesh(
                new THREE.SphereGeometry(3 * scale, 8, 6),
                foliageMat
            );
            canopy.position.y = trunkHeight + 1;
            canopy.scale.y = 0.6;
            canopy.castShadow = true;
            treeGroup.add(canopy);

            treeGroup.position.set(x, 0, z);
            scene.add(treeGroup);
            return { position: new THREE.Vector3(x, 0, z), radius: 2.5 * scale, height: trunkHeight + 4 * scale };
        }

        // Cypress tree (tall and narrow)
        function createCypressTree(x, z, scale = 1) {
            const treeGroup = new THREE.Group();
            const trunkHeight = 2 * scale;
            const trunk = new THREE.Mesh(
                new THREE.CylinderGeometry(0.2 * scale, 0.3 * scale, trunkHeight, 8),
                treeTrunkMat
            );
            trunk.position.y = trunkHeight / 2;
            trunk.castShadow = true;
            treeGroup.add(trunk);

            const foliageMat = new THREE.MeshStandardMaterial({ color: 0x2d4a1a });
            const foliage = new THREE.Mesh(
                new THREE.ConeGeometry(1.5 * scale, 10 * scale, 8),
                foliageMat
            );
            foliage.position.y = trunkHeight + 5 * scale;
            foliage.castShadow = true;
            treeGroup.add(foliage);

            treeGroup.position.set(x, 0, z);
            scene.add(treeGroup);
            return { position: new THREE.Vector3(x, 0, z), radius: 1 * scale, height: trunkHeight + 10 * scale };
        }

        // Maple tree (spreading branches)
        function createMapleTree(x, z, scale = 1) {
            const treeGroup = new THREE.Group();
            const trunkHeight = 3.5 * scale;
            const trunk = new THREE.Mesh(
                new THREE.CylinderGeometry(0.35 * scale, 0.5 * scale, trunkHeight, 8),
                treeTrunkMat
            );
            trunk.position.y = trunkHeight / 2;
            trunk.castShadow = true;
            treeGroup.add(trunk);

            const foliageColors = [0x8b2500, 0xcd3700, 0xff4500, 0x3a7d32];
            const color = foliageColors[Math.floor(Math.random() * foliageColors.length)];
            const foliageMat = new THREE.MeshStandardMaterial({ color: color });

            for (let i = 0; i < 8; i++) {
                const foliage = new THREE.Mesh(
                    new THREE.SphereGeometry(2 * scale + Math.random() * 0.8, 8, 6),
                    foliageMat
                );
                foliage.position.set(
                    (Math.random() - 0.5) * 4 * scale,
                    trunkHeight + Math.random() * 3 * scale,
                    (Math.random() - 0.5) * 4 * scale
                );
                foliage.castShadow = true;
                treeGroup.add(foliage);
            }
            treeGroup.position.set(x, 0, z);
            scene.add(treeGroup);
            return { position: new THREE.Vector3(x, 0, z), radius: 2.5 * scale, height: trunkHeight + 6 * scale };
        }

        // Bush / shrub
        function createBush(x, z, scale = 1) {
            const bushGroup = new THREE.Group();
            const bushColors = [0x3a7d32, 0x4a8d42, 0x2d6b27, 0x5a9d52];
            const color = bushColors[Math.floor(Math.random() * bushColors.length)];
            const bushMat = new THREE.MeshStandardMaterial({ color: color });

            for (let i = 0; i < 4; i++) {
                const sphere = new THREE.Mesh(
                    new THREE.SphereGeometry(0.8 * scale + Math.random() * 0.4, 8, 6),
                    bushMat
                );
                sphere.position.set(
                    (Math.random() - 0.5) * scale,
                    0.6 * scale,
                    (Math.random() - 0.5) * scale
                );
                sphere.castShadow = true;
                bushGroup.add(sphere);
            }
            bushGroup.position.set(x, 0, z);
            scene.add(bushGroup);
            return { position: new THREE.Vector3(x, 0, z), radius: 1 * scale, height: 1.5 * scale };
        }

        const edgeOffset = groundSize / 2 - 20;

        // Very dense forest at edges (500+ trees)
        for (let i = 0; i < 500; i++) {
            const angle = Math.random() * Math.PI * 2;
            const dist = edgeOffset - 20 + Math.random() * 40;
            const x = Math.cos(angle) * dist;
            const z = Math.sin(angle) * dist;
            const scale = 0.5 + Math.random() * 1.0;
            const type = Math.random();

            if (type < 0.25) {
                trees.push(createPineTree(x, z, scale));
            } else if (type < 0.45) {
                trees.push(createOakTree(x, z, scale));
            } else if (type < 0.55) {
                trees.push(createBirchTree(x, z, scale));
            } else if (type < 0.65) {
                trees.push(createWillowTree(x, z, scale));
            } else if (type < 0.75) {
                trees.push(createCypressTree(x, z, scale));
            } else if (type < 0.85) {
                trees.push(createMapleTree(x, z, scale));
            } else if (type < 0.92) {
                trees.push(createPalmTree(x, z, scale));
            } else {
                trees.push(createBush(x, z, scale));
            }
        }

        // Park trees (200+ more between city and edges)
        for (let i = 0; i < 200; i++) {
            const x = (Math.random() - 0.5) * groundSize * 0.7;
            const z = (Math.random() - 0.5) * groundSize * 0.7;
            if (Math.abs(x) < 85 && Math.abs(z) < 85) continue;
            if (z > 80 && z < 100) continue; // Skip train track
            const scale = 0.6 + Math.random() * 0.7;
            const type = Math.random();

            if (type < 0.3) trees.push(createOakTree(x, z, scale));
            else if (type < 0.5) trees.push(createPineTree(x, z, scale));
            else if (type < 0.65) trees.push(createBirchTree(x, z, scale));
            else if (type < 0.8) trees.push(createMapleTree(x, z, scale));
            else trees.push(createBush(x, z, scale * 0.8));
        }

        // Trees near spawn area
        for (let i = 0; i < 50; i++) {
            const x = (Math.random() - 0.5) * 80;
            const z = -140 + Math.random() * 30;
            const scale = 0.6 + Math.random() * 0.6;
            if (Math.random() > 0.5) trees.push(createOakTree(x, z, scale));
            else trees.push(createBirchTree(x, z, scale));
        }

        // Bushes scattered around
        for (let i = 0; i < 150; i++) {
            const x = (Math.random() - 0.5) * groundSize * 0.85;
            const z = (Math.random() - 0.5) * groundSize * 0.85;
            if (Math.abs(x) < 90 && Math.abs(z) < 90) continue;
            trees.push(createBush(x, z, 0.6 + Math.random() * 0.6));
        }

        // --- 10f. VARIED CLOUDS ---
        const clouds = [];

        function createCloud(x, y, z, type = 'normal') {
            const cloudGroup = new THREE.Group();
            const cloudMat = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: type === 'wispy' ? 0.6 : 0.85,
                roughness: 1
            });

            let numPuffs, puffSize, spread;

            let vertical = 1;

            switch(type) {
                case 'large':
                    numPuffs = 12 + Math.floor(Math.random() * 8);
                    puffSize = 15;
                    spread = 50;
                    break;
                case 'wispy':
                    numPuffs = 3 + Math.floor(Math.random() * 3);
                    puffSize = 6;
                    spread = 40;
                    cloudMat.opacity = 0.5;
                    break;
                case 'storm':
                    numPuffs = 20 + Math.floor(Math.random() * 10);
                    puffSize = 20;
                    spread = 60;
                    cloudMat.color.setHex(0xaaaaaa);
                    break;
                case 'towering':
                    numPuffs = 15 + Math.floor(Math.random() * 10);
                    puffSize = 18;
                    spread = 35;
                    vertical = 2.5;
                    break;
                case 'flat':
                    numPuffs = 8 + Math.floor(Math.random() * 6);
                    puffSize = 12;
                    spread = 70;
                    vertical = 0.3;
                    cloudMat.opacity = 0.7;
                    break;
                case 'puffy':
                    numPuffs = 6 + Math.floor(Math.random() * 4);
                    puffSize = 14;
                    spread = 25;
                    break;
                default:
                    numPuffs = 5 + Math.floor(Math.random() * 5);
                    puffSize = 10;
                    spread = 30;
            }

            for (let i = 0; i < numPuffs; i++) {
                const size = puffSize * (0.5 + Math.random());
                const puff = new THREE.Mesh(
                    new THREE.SphereGeometry(size, 8, 6),
                    cloudMat
                );
                puff.position.set(
                    (Math.random() - 0.5) * spread,
                    (Math.random() - 0.5) * (puffSize * vertical),
                    (Math.random() - 0.5) * (spread * 0.5)
                );
                puff.scale.y = (0.5 + Math.random() * 0.3) * (vertical > 1 ? 1.5 : 1);
                cloudGroup.add(puff);
            }

            cloudGroup.position.set(x, y, z);

            const cloudData = {
                group: cloudGroup,
                baseY: y,
                speedX: (Math.random() - 0.5) * 3,
                speedZ: (Math.random() - 0.5) * 1.5,
                bobSpeed: 0.3 + Math.random() * 0.4,
                bobAmount: 1 + Math.random() * 2,
                phase: Math.random() * Math.PI * 2,
                rotationSpeed: (Math.random() - 0.5) * 0.02
            };

            scene.add(cloudGroup);
            return cloudData;
        }

        // Create massive cloud coverage
        // Normal fluffy clouds - 60 clouds
        for (let i = 0; i < 60; i++) {
            const x = (Math.random() - 0.5) * groundSize * 2.5;
            const y = 65 + Math.random() * 45;
            const z = (Math.random() - 0.5) * groundSize * 2.5;
            clouds.push(createCloud(x, y, z, 'normal'));
        }
        // Large cumulus clouds - 30 clouds
        for (let i = 0; i < 30; i++) {
            const x = (Math.random() - 0.5) * groundSize * 2.5;
            const y = 90 + Math.random() * 60;
            const z = (Math.random() - 0.5) * groundSize * 2.5;
            clouds.push(createCloud(x, y, z, 'large'));
        }
        // Wispy cirrus clouds - 40 clouds
        for (let i = 0; i < 40; i++) {
            const x = (Math.random() - 0.5) * groundSize * 2.5;
            const y = 55 + Math.random() * 35;
            const z = (Math.random() - 0.5) * groundSize * 2.5;
            clouds.push(createCloud(x, y, z, 'wispy'));
        }
        // Storm clouds - 10 clouds
        for (let i = 0; i < 10; i++) {
            const x = (Math.random() - 0.5) * groundSize * 2;
            const y = 110 + Math.random() * 40;
            const z = (Math.random() - 0.5) * groundSize * 2;
            clouds.push(createCloud(x, y, z, 'storm'));
        }
        // High altitude thin clouds - 25 clouds
        for (let i = 0; i < 25; i++) {
            const x = (Math.random() - 0.5) * groundSize * 3;
            const y = 140 + Math.random() * 50;
            const z = (Math.random() - 0.5) * groundSize * 3;
            clouds.push(createCloud(x, y, z, 'wispy'));
        }
        // Low hanging clouds near city - 20 clouds
        for (let i = 0; i < 20; i++) {
            const x = (Math.random() - 0.5) * groundSize * 1.5;
            const y = 45 + Math.random() * 25;
            const z = (Math.random() - 0.5) * groundSize * 1.5;
            clouds.push(createCloud(x, y, z, 'normal'));
        }
        // Extra large dramatic clouds - 15 clouds
        for (let i = 0; i < 15; i++) {
            const x = (Math.random() - 0.5) * groundSize * 2;
            const y = 100 + Math.random() * 70;
            const z = (Math.random() - 0.5) * groundSize * 2;
            clouds.push(createCloud(x, y, z, 'large'));
        }
        // Scattered small puffs - 50 clouds
        for (let i = 0; i < 50; i++) {
            const x = (Math.random() - 0.5) * groundSize * 2.5;
            const y = 50 + Math.random() * 60;
            const z = (Math.random() - 0.5) * groundSize * 2.5;
            clouds.push(createCloud(x, y, z, 'wispy'));
        }
        // Towering cumulus clouds - 12 clouds
        for (let i = 0; i < 12; i++) {
            const x = (Math.random() - 0.5) * groundSize * 2;
            const y = 80 + Math.random() * 40;
            const z = (Math.random() - 0.5) * groundSize * 2;
            clouds.push(createCloud(x, y, z, 'towering'));
        }
        // Flat stratus clouds - 20 clouds
        for (let i = 0; i < 20; i++) {
            const x = (Math.random() - 0.5) * groundSize * 2.5;
            const y = 55 + Math.random() * 30;
            const z = (Math.random() - 0.5) * groundSize * 2.5;
            clouds.push(createCloud(x, y, z, 'flat'));
        }
        // Puffy cotton-ball clouds - 35 clouds
        for (let i = 0; i < 35; i++) {
            const x = (Math.random() - 0.5) * groundSize * 2;
            const y = 70 + Math.random() * 50;
            const z = (Math.random() - 0.5) * groundSize * 2;
            clouds.push(createCloud(x, y, z, 'puffy'));
        }
        // Very high altitude wisps - 30 clouds
        for (let i = 0; i < 30; i++) {
            const x = (Math.random() - 0.5) * groundSize * 3;
            const y = 180 + Math.random() * 60;
            const z = (Math.random() - 0.5) * groundSize * 3;
            clouds.push(createCloud(x, y, z, 'flat'));
        }

        // Cloud update function
        function updateClouds(dt) {
            const time = performance.now() * 0.001;
            clouds.forEach(cloud => {
                cloud.group.position.x += cloud.speedX * dt;
                cloud.group.position.z += cloud.speedZ * dt;
                cloud.group.position.y = cloud.baseY + Math.sin(time * cloud.bobSpeed + cloud.phase) * cloud.bobAmount;
                cloud.group.rotation.y += cloud.rotationSpeed * dt;

                const limit = groundSize * 1.2;
                if (cloud.group.position.x > limit) cloud.group.position.x = -limit;
                if (cloud.group.position.x < -limit) cloud.group.position.x = limit;
                if (cloud.group.position.z > limit) cloud.group.position.z = -limit;
                if (cloud.group.position.z < -limit) cloud.group.position.z = limit;
            });
        }

        // --- 10g. START/FINISH BANNER ---
        const bannerPoleGeom = new THREE.CylinderGeometry(0.2, 0.2, 8, 8);
        const bannerPoleMat = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });

        const leftBannerPole = new THREE.Mesh(bannerPoleGeom, bannerPoleMat);
        leftBannerPole.position.set(-8, 4, 5);
        leftBannerPole.castShadow = true;
        scene.add(leftBannerPole);

        const rightBannerPole = new THREE.Mesh(bannerPoleGeom, bannerPoleMat);
        rightBannerPole.position.set(8, 4, 5);
        rightBannerPole.castShadow = true;
        scene.add(rightBannerPole);

        // --- 11. COLLISION DETECTION ---
        function checkBuildingCollision() {
            for (const building of buildings) {
                const dx = physics.position.x - building.position.x;
                const dz = physics.position.z - building.position.z;

                // Check if within building's bounding box
                if (Math.abs(dx) < building.width / 2 + physics.droneRadius &&
                    Math.abs(dz) < building.depth / 2 + physics.droneRadius &&
                    physics.position.y < building.height) {
                    return true;
                }
            }
            return false;
        }

        function checkTreeCollision() {
            for (const tree of trees) {
                const dx = physics.position.x - tree.position.x;
                const dz = physics.position.z - tree.position.z;
                const horizontalDist = Math.sqrt(dx * dx + dz * dz);

                // Check if within tree's collision cylinder
                if (horizontalDist < tree.radius + physics.droneRadius &&
                    physics.position.y < tree.height) {
                    return true;
                }
            }
            return false;
        }

        function checkGroundCollision() {
            const groundLevel = 0;
            if (physics.position.y < groundLevel + physics.droneRadius) {
                const impactSpeed = Math.abs(physics.velocity.y);
                if (impactSpeed > 3) {
                    return true; // Crash
                }
                // Soft landing - just stop
                physics.position.y = groundLevel + physics.droneRadius;
                physics.velocity.y = Math.max(0, physics.velocity.y);
            }
            return false;
        }

        function checkGatePass() {
            if (gameState.mode !== 'racing') return;

            const nextGateIndex = gameState.currentGate;
            if (nextGateIndex >= gates.length) return;

            const gate = gates[nextGateIndex];
            const dronePos = physics.position;

            // Check if drone is near the gate plane
            const toGate = new THREE.Vector3().subVectors(dronePos, gate.position);
            const distAlongForward = toGate.dot(gate.forward);

            // Check if crossed the gate plane (from front to back)
            if (Math.abs(distAlongForward) < 2) {
                const lateralDist = Math.sqrt(
                    Math.pow(toGate.x - distAlongForward * gate.forward.x, 2) +
                    Math.pow(toGate.z - distAlongForward * gate.forward.z, 2)
                );
                const heightFromGate = dronePos.y - gate.position.y;

                // Check if within gate bounds
                if (lateralDist < gate.width / 2 &&
                    Math.abs(heightFromGate) < gate.height / 2) {

                    // Gate passed!
                    gate.passed = true;
                    gate.poles.forEach(pole => pole.material = gate.passedMat);
                    gameState.currentGate++;

                    updateGateCounter();

                    if (gameState.currentGate >= gates.length) {
                        // Lap complete!
                        completeLap();
                    } else {
                        showNotification(`Gate ${nextGateIndex + 1} cleared!`);
                    }
                }
            }
        }

        function checkGateCollision() {
            // Simplified: check collision with gate poles
            for (const gate of gates) {
                const dx = physics.position.x - gate.position.x;
                const dy = physics.position.y - gate.position.y;
                const dz = physics.position.z - gate.position.z;

                // Only check if near the gate
                if (Math.abs(dx) > 5 || Math.abs(dz) > 5) continue;

                // Check pole collision (simplified bounding boxes)
                const poleRadius = 0.3;
                const halfWidth = gate.width / 2;

                // Transform drone position to gate local space
                const cosR = Math.cos(-gate.group.rotation.y);
                const sinR = Math.sin(-gate.group.rotation.y);
                const localX = dx * cosR - dz * sinR;
                const localZ = dx * sinR + dz * cosR;

                // Check left pole
                if (Math.abs(localX + halfWidth) < poleRadius + physics.droneRadius &&
                    Math.abs(localZ) < poleRadius + physics.droneRadius &&
                    dy > 0 && dy < gate.height) {
                    return true;
                }
                // Check right pole
                if (Math.abs(localX - halfWidth) < poleRadius + physics.droneRadius &&
                    Math.abs(localZ) < poleRadius + physics.droneRadius &&
                    dy > 0 && dy < gate.height) {
                    return true;
                }
                // Check top bar
                if (Math.abs(dy - gate.height) < poleRadius + physics.droneRadius &&
                    Math.abs(localZ) < poleRadius + physics.droneRadius &&
                    Math.abs(localX) < halfWidth) {
                    return true;
                }
            }
            return false;
        }

        // --- 12. GAME FLOW ---
        function triggerCrash() {
            physics.crashed = true;
            physics.velocity.set(0, 0, 0);
            gameState.mode = 'crashed';
            document.getElementById('crash-overlay').style.display = 'flex';
            showNotification('Crashed! Press R to reset');
        }

        function resetDrone() {
            physics.position.copy(spawnPoint);
            physics.velocity.set(0, 0, 0);
            physics.crashed = false;
            droneGroup.rotation.set(0, 0, 0);
            droneGroup.position.copy(spawnPoint);

            document.getElementById('crash-overlay').style.display = 'none';

            if (gameState.mode === 'crashed' || gameState.mode === 'racing') {
                gameState.mode = 'freefly';
                gameState.currentGate = 0;
                document.getElementById('race-info').style.display = 'none';

                // Reset gate colors
                gates.forEach(gate => {
                    gate.passed = false;
                    gate.poles.forEach(pole => pole.material = gate.poleMat);
                });
            }

            showNotification('Drone reset');
        }

        function startRace() {
            if (gameState.mode !== 'freefly') return;

            resetDrone();
            gameState.mode = 'countdown';

            const countdownOverlay = document.getElementById('countdown-overlay');
            const countdownText = document.getElementById('countdown-text');
            countdownOverlay.style.display = 'flex';

            let count = 3;
            countdownText.textContent = count;

            const countdownInterval = setInterval(() => {
                count--;
                if (count > 0) {
                    countdownText.textContent = count;
                } else if (count === 0) {
                    countdownText.textContent = 'GO!';
                } else {
                    clearInterval(countdownInterval);
                    countdownOverlay.style.display = 'none';
                    gameState.mode = 'racing';
                    gameState.raceStartTime = performance.now();
                    gameState.currentGate = 0;
                    document.getElementById('race-info').style.display = 'block';
                    updateGateCounter();
                }
            }, 1000);
        }

        function completeLap() {
            const lapTime = (performance.now() - gameState.raceStartTime) / 1000;
            gameState.lapTimes.push(lapTime);

            if (!gameState.bestLap || lapTime < gameState.bestLap) {
                gameState.bestLap = lapTime;
                localStorage.setItem('fpv_best_lap', lapTime.toString());
                showNotification(`New best lap: ${formatTime(lapTime)}!`);
            } else {
                showNotification(`Lap complete: ${formatTime(lapTime)}`);
            }

            // Reset for next lap
            gameState.mode = 'freefly';
            gameState.currentGate = 0;
            document.getElementById('race-info').style.display = 'none';

            gates.forEach(gate => {
                gate.passed = false;
                gate.poles.forEach(pole => pole.material = gate.poleMat);
            });

            updateBestLap();
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            const ms = Math.floor((seconds % 1) * 1000);
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}`;
        }

        function updateGateCounter() {
            document.getElementById('gate-counter').textContent =
                `Gate ${gameState.currentGate} / ${gameState.totalGates}`;
        }

        function updateBestLap() {
            const bestLapEl = document.getElementById('best-lap');
            bestLapEl.textContent = gameState.bestLap ? formatTime(gameState.bestLap) : '--:--';
        }

        // --- 13. BETAFLIGHT ACTUAL RATES ---
        function calculateActualRate(input, centerSens, maxRate, expo) {
            const deflection = Math.abs(input);
            if (deflection < 0.02) return 0;

            const s = centerSens;
            const m = maxRate;
            const e = expo;

            const curve = Math.pow(deflection, 1 + (e * 3));
            const rateMag = s + (m - s) * curve;

            return (deflection * rateMag) * Math.sign(input);
        }

        // --- 14. PHYSICS UPDATE ---
        function updatePhysics(dt, rawRoll, rawPitch, rawYaw, rawThrottle) {
            if (physics.crashed) return;

            // Clamp dt to prevent explosion on tab switch
            dt = Math.min(dt, 0.05);

            // Get rate values from UI
            const rC = parseFloat(document.getElementById('roll-center').value);
            const rM = parseFloat(document.getElementById('roll-max').value);
            const rE = parseFloat(document.getElementById('roll-expo').value);
            const pC = parseFloat(document.getElementById('pitch-center').value);
            const pM = parseFloat(document.getElementById('pitch-max').value);
            const pE = parseFloat(document.getElementById('pitch-expo').value);
            const yC = parseFloat(document.getElementById('yaw-center').value);
            const yM = parseFloat(document.getElementById('yaw-max').value);
            const yE = parseFloat(document.getElementById('yaw-expo').value);

            // Calculate rotation rates
            const rollRate = calculateActualRate(rawRoll, rC, rM, rE);
            const pitchRate = calculateActualRate(rawPitch, pC, pM, pE);
            const yawRate = calculateActualRate(rawYaw, yC, yM, yE);

            // Apply rotations (in drone's local frame)
            droneGroup.rotateX(THREE.MathUtils.degToRad(pitchRate * dt));
            droneGroup.rotateY(THREE.MathUtils.degToRad(yawRate * dt));
            droneGroup.rotateZ(THREE.MathUtils.degToRad(-rollRate * dt));

            // Calculate thrust (throttle 0-1 mapped from -1 to 1 input)
            const throttle01 = (rawThrottle + 1) / 2;
            const thrustMagnitude = throttle01 * physics.maxThrust;

            // Get drone's up vector (local Y in world space)
            const thrustDir = new THREE.Vector3(0, 1, 0);
            thrustDir.applyQuaternion(droneGroup.quaternion);

            // Apply thrust
            const thrust = thrustDir.multiplyScalar(thrustMagnitude);

            // Acceleration = thrust/mass - gravity
            const acceleration = new THREE.Vector3(
                thrust.x,
                thrust.y - physics.gravity,
                thrust.z
            );

            // Update velocity
            physics.velocity.add(acceleration.multiplyScalar(dt));

            // Apply drag
            const dragFactor = 1 - physics.dragCoeff * dt;
            physics.velocity.multiplyScalar(dragFactor);

            // Update position
            physics.position.add(physics.velocity.clone().multiplyScalar(dt));

            // Bounds check
            const bound = groundSize / 2 - 10;
            physics.position.x = THREE.MathUtils.clamp(physics.position.x, -bound, bound);
            physics.position.z = THREE.MathUtils.clamp(physics.position.z, -bound, bound);
            physics.position.y = Math.max(physics.position.y, physics.droneRadius);

            // Sync drone group position
            droneGroup.position.copy(physics.position);

            // Check collisions
            if (checkGroundCollision()) {
                triggerCrash();
                return;
            }

            if (checkGateCollision()) {
                triggerCrash();
                return;
            }

            if (checkTreeCollision()) {
                triggerCrash();
                return;
            }

            if (checkBuildingCollision()) {
                triggerCrash();
                return;
            }

            checkGatePass();
        }

        // --- 15. CAMERA UPDATE ---
        // Pre-calculate the 180Â° flip quaternion (cameras look down -Z, drone forward is +Z)
        const cameraFlipQuat = new THREE.Quaternion();
        cameraFlipQuat.setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI);

        function updateCamera(dt) {
            // FPV camera rigidly attached to front of drone body

            // Camera position in drone's local space (front of drone, between front props)
            const localOffset = cameraController.offset.clone();
            localOffset.applyQuaternion(droneGroup.quaternion);
            const camPos = physics.position.clone().add(localOffset);

            // Set camera position
            camera.position.copy(camPos);

            // Start with drone's rotation
            camera.quaternion.copy(droneGroup.quaternion);

            // Flip camera 180Â° around Y so it looks forward (+Z) instead of backward (-Z)
            camera.quaternion.multiply(cameraFlipQuat);

            // Apply camera tilt (rotation around local X axis)
            const tiltQuat = new THREE.Quaternion();
            tiltQuat.setFromAxisAngle(new THREE.Vector3(1, 0, 0), THREE.MathUtils.degToRad(cameraController.tiltAngle));
            camera.quaternion.multiply(tiltQuat);
        }

        // --- 16. HUD UPDATE ---
        function updateHUD(throttle01) {
            const speed = physics.velocity.length();
            const alt = physics.position.y;

            document.getElementById('hud-speed').textContent = speed.toFixed(1);
            document.getElementById('hud-alt').textContent = alt.toFixed(1);
            document.getElementById('hud-throttle').textContent = Math.round(throttle01 * 100);
            document.getElementById('hud-tilt').textContent = cameraController.tiltAngle;

            if (gameState.mode === 'racing') {
                const elapsed = (performance.now() - gameState.raceStartTime) / 1000;
                document.getElementById('race-time').textContent = formatTime(elapsed);
            }
        }

        // --- 17. PROP ANIMATION ---
        function animateProps(throttle01) {
            const spinSpeed = throttle01 * 50;
            propellers.forEach((prop, i) => {
                prop.rotation.y += spinSpeed * (i % 2 === 0 ? 1 : -1) * 0.1;
            });
        }

        // --- 18. INPUT HANDLING ---
        let activeGamepadIndex = null;

        window.addEventListener("gamepadconnected", (e) => {
            activeGamepadIndex = e.gamepad.index;
            showNotification(`Connected: ${e.gamepad.id}`);
        });
        window.addEventListener("gamepaddisconnected", () => {
            activeGamepadIndex = null;
            showNotification("Controller disconnected");
        });

        // Keyboard controls
        window.addEventListener('keydown', (e) => {
            if (e.code === 'KeyR') {
                resetDrone();
            } else if (e.code === 'Space' || e.code === 'Enter') {
                if (gameState.mode === 'freefly') {
                    startRace();
                }
            } else if (e.code === 'Escape') {
                if (gameState.mode === 'racing') {
                    gameState.mode = 'freefly';
                    document.getElementById('race-info').style.display = 'none';
                    showNotification('Race cancelled');
                }
            } else if (e.code === 'KeyW') {
                // Tilt camera up
                cameraController.tiltAngle = Math.min(
                    cameraController.maxTilt,
                    cameraController.tiltAngle + 5
                );
                showNotification(`Camera tilt: ${cameraController.tiltAngle}Â°`);
            } else if (e.code === 'KeyS') {
                // Tilt camera down
                cameraController.tiltAngle = Math.max(
                    cameraController.minTilt,
                    cameraController.tiltAngle - 5
                );
                showNotification(`Camera tilt: ${cameraController.tiltAngle}Â°`);
            }
        });

        // Mode buttons
        document.getElementById('mode-freefly').addEventListener('click', () => {
            document.getElementById('mode-freefly').classList.add('active');
            document.getElementById('mode-race').classList.remove('active');
            if (gameState.mode === 'racing') {
                gameState.mode = 'freefly';
                document.getElementById('race-info').style.display = 'none';
            }
        });

        document.getElementById('mode-race').addEventListener('click', () => {
            document.getElementById('mode-race').classList.add('active');
            document.getElementById('mode-freefly').classList.remove('active');
            startRace();
        });

        // Reset button
        document.getElementById('reset-cam').addEventListener('click', resetDrone);

        // --- 19. CONTROLLER MAPPING UI ---
        const modal = document.getElementById('mapping-modal');
        const rowsContainer = document.getElementById('mapping-rows');
        const functions = ['Roll', 'Pitch', 'Yaw', 'Throttle'];

        document.getElementById('open-mapping').addEventListener('click', () => {
            if (activeGamepadIndex === null) {
                showNotification("Connect controller first!");
                return;
            }
            renderMappingUI();
            modal.style.display = 'flex';
        });

        document.getElementById('close-mapping').addEventListener('click', () => {
            modal.style.display = 'none';
            saveConfig();
            showNotification("Mapping saved");
        });

        function renderMappingUI() {
            rowsContainer.innerHTML = '';

            functions.forEach(func => {
                const key = func.toLowerCase();
                const setting = config.mapping[key];

                const row = document.createElement('div');
                row.className = 'map-row';

                const label = document.createElement('div');
                label.className = 'map-label';
                label.innerText = func;

                const select = document.createElement('select');
                select.className = 'map-select';
                for (let i = 0; i < 8; i++) {
                    const opt = document.createElement('option');
                    opt.value = i;
                    opt.innerText = `Axis ${i}`;
                    if (i === setting.axis) opt.selected = true;
                    select.appendChild(opt);
                }
                select.onchange = (e) => config.mapping[key].axis = parseInt(e.target.value);

                const invertDiv = document.createElement('div');
                invertDiv.className = 'map-invert';
                const chk = document.createElement('input');
                chk.type = 'checkbox';
                chk.checked = setting.invert;
                chk.onchange = (e) => config.mapping[key].invert = e.target.checked;
                invertDiv.appendChild(chk);
                invertDiv.appendChild(document.createTextNode('Inv'));

                const viz = document.createElement('div');
                viz.className = 'axis-viz';
                const bar = document.createElement('div');
                bar.className = 'axis-bar';
                bar.id = `viz-${key}`;
                viz.appendChild(bar);

                row.appendChild(label);
                row.appendChild(select);
                row.appendChild(invertDiv);
                row.appendChild(viz);
                rowsContainer.appendChild(row);
            });
        }

        // --- 20. WINDOW RESIZE ---
        window.addEventListener('resize', () => {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });

        // --- 21. MAIN ANIMATION LOOP ---
        const clock = new THREE.Clock();
        updateBestLap();

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();

            let rawRoll = 0, rawPitch = 0, rawYaw = 0, rawThrottle = -1;

            if (activeGamepadIndex !== null) {
                const gp = navigator.getGamepads()[activeGamepadIndex];
                if (gp) {
                    const getAxisVal = (name) => {
                        const map = config.mapping[name];
                        let val = gp.axes[map.axis] || 0;
                        if (map.invert) val *= -1;
                        return val;
                    };

                    rawRoll = getAxisVal('roll');
                    rawPitch = getAxisVal('pitch');
                    rawYaw = getAxisVal('yaw');
                    rawThrottle = getAxisVal('throttle');

                    // Update mapping visualizers if modal is open
                    if (modal.style.display === 'flex') {
                        const updateViz = (name, val) => {
                            const bar = document.getElementById(`viz-${name}`);
                            if (bar) {
                                const pct = (val + 1) * 50;
                                bar.style.left = val < 0 ? `${pct}%` : '50%';
                                bar.style.width = `${Math.abs(val) * 50}%`;
                            }
                        };
                        updateViz('roll', rawRoll);
                        updateViz('pitch', rawPitch);
                        updateViz('yaw', rawYaw);
                        updateViz('throttle', rawThrottle);
                    }
                }
            }

            // Update systems
            if (gameState.mode !== 'countdown') {
                updatePhysics(dt, rawRoll, rawPitch, rawYaw, rawThrottle);
            }
            updateCamera(dt);

            const throttle01 = (rawThrottle + 1) / 2;
            updateHUD(throttle01);
            animateProps(throttle01);
            updateClouds(dt);
            updateTrain(dt);

            renderer.render(scene, camera);
        }

        animate();

    </script>
</body>
</html>
