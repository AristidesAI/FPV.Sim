<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FPV Racing Simulator - Betaflight Actual Rates</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #2196F3;
            --accent: #FFC107;
            --bg-light: #f5f5f5;
            --surface-light: #ffffff;
            --text-light: #333333;
            --bg-dark: #121212;
            --surface-dark: #1e1e1e;
            --text-dark: #e0e0e0;
            --border-radius: 12px;
        }

        body {
            margin: 0;
            font-family: 'Roboto', sans-serif;
            overflow: hidden;
            display: flex;
            height: 100vh;
            background-color: var(--bg-light);
            color: var(--text-light);
            transition: background-color 0.3s, color 0.3s;
        }

        body.dark-mode {
            background-color: var(--bg-dark);
            color: var(--text-dark);
        }

        /* --- SIDEBAR --- */
        #sidebar {
            width: 340px;
            padding: 20px;
            background-color: var(--surface-light);
            box-shadow: 2px 0 10px rgba(0,0,0,0.05);
            display: flex;
            flex-direction: column;
            gap: 15px;
            z-index: 20;
            overflow-y: auto;
            transition: background-color 0.3s;
        }

        body.dark-mode #sidebar { background-color: var(--surface-dark); }

        h2 { margin: 0; font-weight: 700; font-size: 1.5rem; }
        h3 { margin: 0 0 8px 0; font-size: 0.85rem; text-transform: uppercase; color: var(--primary); letter-spacing: 0.5px; }

        .control-group {
            background: rgba(0,0,0,0.04);
            padding: 12px;
            border-radius: var(--border-radius);
        }
        body.dark-mode .control-group { background: rgba(255,255,255,0.05); }

        .input-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        .input-row label { font-size: 0.8rem; flex: 1; }
        .input-row input {
            width: 70px;
            padding: 6px;
            border: 1px solid #ccc;
            border-radius: 6px;
            background: transparent;
            color: inherit;
            text-align: right;
        }

        /* --- BUTTONS --- */
        button {
            padding: 12px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: 0.2s;
            width: 100%;
            margin-bottom: 5px;
        }
        button:hover { filter: brightness(1.1); }
        
        .btn-primary { background-color: var(--primary); color: white; }
        .btn-secondary { background-color: #607D8B; color: white; }
        .btn-accent { background-color: var(--accent); color: #333; }

        /* --- CANVAS --- */
        #canvas-container {
            flex-grow: 1;
            position: relative;
            background: radial-gradient(circle at center, #e0e0e0 0%, #bdbdbd 100%);
        }
        body.dark-mode #canvas-container {
            background: radial-gradient(circle at center, #2c2c2c 0%, #000000 100%);
        }

        /* --- MAPPING MODAL --- */
        #mapping-modal {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6);
            z-index: 100;
            display: none; /* Hidden by default */
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(4px);
        }
        .modal-content {
            background: var(--surface-light);
            padding: 25px;
            border-radius: 16px;
            width: 450px;
            max-width: 90%;
            color: var(--text-light);
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
        }
        body.dark-mode .modal-content {
            background: var(--surface-dark);
            color: var(--text-dark);
        }
        
        .map-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(0,0,0,0.1);
        }
        body.dark-mode .map-row { border-bottom: 1px solid rgba(255,255,255,0.1); }
        
        .map-label { width: 60px; font-weight: bold; }
        .map-select { flex: 1; padding: 8px; border-radius: 6px; }
        .map-invert { display: flex; align-items: center; gap: 5px; font-size: 0.8rem; }
        .axis-viz {
            width: 100px;
            height: 10px;
            background: #ddd;
            border-radius: 5px;
            position: relative;
            overflow: hidden;
        }
        .axis-bar {
            position: absolute;
            top: 0; left: 50%;
            height: 100%;
            width: 0%; /* Dynamic */
            background: var(--primary);
            transition: width 0.05s, left 0.05s;
        }

        /* --- NOTIFICATIONS --- */
        #notification-area {
            position: absolute;
            top: 20px; right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 200;
        }
        .toast {
            background-color: var(--surface-light);
            color: var(--text-light);
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            border-left: 5px solid var(--primary);
            animation: slideIn 0.3s ease-out;
        }
        body.dark-mode .toast { background-color: var(--surface-dark); color: var(--text-dark); }
        @keyframes slideIn { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }

        /* --- HUD OVERLAY --- */
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            font-family: 'Roboto Mono', monospace;
            font-size: 14px;
            color: white;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.8);
            pointer-events: none;
            z-index: 50;
        }
        .hud-row {
            margin-bottom: 5px;
            display: flex;
            gap: 15px;
        }
        .hud-label { opacity: 0.7; }
        .hud-value { font-weight: bold; min-width: 60px; }

        /* --- CRASH OVERLAY --- */
        #crash-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(180, 0, 0, 0.6);
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 80;
            backdrop-filter: blur(3px);
        }
        #crash-overlay h1 {
            font-size: 4rem;
            color: white;
            margin: 0;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.5);
        }
        #crash-overlay p {
            font-size: 1.2rem;
            color: white;
            opacity: 0.9;
        }

        /* --- COUNTDOWN OVERLAY --- */
        #countdown-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 75;
            pointer-events: none;
        }
        #countdown-text {
            font-size: 8rem;
            font-weight: bold;
            color: white;
            text-shadow: 4px 4px 10px rgba(0,0,0,0.7);
        }

        /* --- RACE INFO --- */
        #race-info {
            position: absolute;
            top: 20px;
            right: 380px;
            background: rgba(0,0,0,0.6);
            padding: 15px 20px;
            border-radius: 10px;
            color: white;
            font-family: 'Roboto Mono', monospace;
            z-index: 50;
            display: none;
        }
        #race-info .time { font-size: 2rem; font-weight: bold; }
        #race-info .lap-info { font-size: 0.9rem; opacity: 0.8; margin-top: 5px; }
        #race-info .gate-info { font-size: 1rem; margin-top: 8px; color: #4CAF50; }

        /* --- MODE BUTTONS --- */
        .mode-btn-group {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }
        .mode-btn {
            flex: 1;
            padding: 10px;
            font-size: 0.85rem;
        }
        .mode-btn.active {
            background-color: var(--accent) !important;
            color: #333 !important;
        }

        /* --- KEYBOARD HINTS --- */
        .key-hints {
            font-size: 0.75rem;
            opacity: 0.6;
            margin-top: 10px;
            line-height: 1.6;
        }
        .key {
            background: rgba(255,255,255,0.2);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
        }

    </style>
</head>
<body>

    <div id="sidebar">
        <div>
            <h2>FPV Racing Sim</h2>
            <p style="font-size: 0.8rem; opacity: 0.7; margin-top:5px;">Betaflight Actual Rates</p>
        </div>

        <div class="control-group">
            <h3>Game Mode</h3>
            <div class="mode-btn-group">
                <button id="mode-freefly" class="btn-secondary mode-btn active">Free Flight</button>
                <button id="mode-race" class="btn-secondary mode-btn">Race</button>
            </div>
            <div class="key-hints">
                <span class="key">R</span> Reset &nbsp;
                <span class="key">Space</span> Start Race<br>
                <span class="key">Esc</span> Free Flight<br>
                <span class="key">W</span>/<span class="key">S</span> Camera Tilt
            </div>
        </div>

        <button id="open-mapping" class="btn-accent">Configure Controller</button>

        <div class="control-group">
            <h3>Roll</h3>
            <div class="input-row"><label>Center Sens</label><input type="number" id="roll-center" value="70"></div>
            <div class="input-row"><label>Max Rate</label><input type="number" id="roll-max" value="670"></div>
            <div class="input-row"><label>Expo</label><input type="number" id="roll-expo" value="0.55" step="0.01"></div>
        </div>

        <div class="control-group">
            <h3>Pitch</h3>
            <div class="input-row"><label>Center Sens</label><input type="number" id="pitch-center" value="70"></div>
            <div class="input-row"><label>Max Rate</label><input type="number" id="pitch-max" value="670"></div>
            <div class="input-row"><label>Expo</label><input type="number" id="pitch-expo" value="0.55" step="0.01"></div>
        </div>

        <div class="control-group">
            <h3>Yaw</h3>
            <div class="input-row"><label>Center Sens</label><input type="number" id="yaw-center" value="70"></div>
            <div class="input-row"><label>Max Rate</label><input type="number" id="yaw-max" value="670"></div>
            <div class="input-row"><label>Expo</label><input type="number" id="yaw-expo" value="0.55" step="0.01"></div>
        </div>

        <div style="margin-top: auto;">
            <button id="reset-cam" class="btn-secondary">Reset View</button>
            <button id="theme-toggle" class="btn-primary">Toggle Dark Mode</button>
        </div>
    </div>

    <div id="canvas-container">
        <!-- HUD Overlay -->
        <div id="hud">
            <div class="hud-row">
                <span class="hud-label">Speed:</span>
                <span class="hud-value" id="hud-speed">0</span>
                <span>m/s</span>
            </div>
            <div class="hud-row">
                <span class="hud-label">Alt:</span>
                <span class="hud-value" id="hud-alt">0</span>
                <span>m</span>
            </div>
            <div class="hud-row">
                <span class="hud-label">Throttle:</span>
                <span class="hud-value" id="hud-throttle">0</span>
                <span>%</span>
            </div>
            <div class="hud-row">
                <span class="hud-label">Cam Tilt:</span>
                <span class="hud-value" id="hud-tilt">15</span>
                <span>Â°</span>
            </div>
        </div>

        <!-- Race Info Panel -->
        <div id="race-info">
            <div class="time" id="race-time">00:00.000</div>
            <div class="lap-info">Best: <span id="best-lap">--:--</span></div>
            <div class="gate-info" id="gate-counter">Gate 0 / 0</div>
        </div>

        <!-- Crash Overlay -->
        <div id="crash-overlay">
            <h1>CRASHED!</h1>
            <p>Press <strong>R</strong> to reset</p>
        </div>

        <!-- Countdown Overlay -->
        <div id="countdown-overlay">
            <div id="countdown-text">3</div>
        </div>
    </div>

    <div id="notification-area"></div>

    <div id="mapping-modal">
        <div class="modal-content">
            <h2 style="margin-bottom: 20px;">Controller Mapping</h2>
            <p style="font-size: 0.9rem; margin-bottom: 20px; opacity: 0.8;">
                Move your sticks to identify axes. Assign them to the correct functions.
            </p>

            <div id="mapping-rows"></div>

            <button id="close-mapping" class="btn-primary" style="margin-top: 20px;">Save & Close</button>
        </div>
    </div>

    <script>
        // ============================================================
        // FPV RACING SIMULATOR - BETAFLIGHT ACTUAL RATES
        // ============================================================

        // --- 1. STATE & CONFIGURATION ---
        let config = {
            mapping: {
                roll: { axis: 2, invert: false },
                pitch: { axis: 3, invert: false },
                yaw: { axis: 0, invert: true },
                throttle: { axis: 1, invert: true }
            }
        };

        // Load saved config
        const savedConfig = localStorage.getItem('bf_rate_config');
        if (savedConfig) {
            try {
                const parsed = JSON.parse(savedConfig);
                if (parsed.mapping) config.mapping = parsed.mapping;
            } catch(e) { console.log('Config load error'); }
        }

        function saveConfig() {
            localStorage.setItem('bf_rate_config', JSON.stringify(config));
        }

        // --- 2. PHYSICS STATE ---
        const physics = {
            position: new THREE.Vector3(0, 5, -120),
            velocity: new THREE.Vector3(0, 0, 0),
            gravity: 9.81,
            dragCoeff: 0.4,       // Air resistance
            maxThrust: 30,        // Max thrust force (gives good power-to-weight)
            crashed: false,
            droneRadius: 0.5
        };

        const spawnPoint = new THREE.Vector3(0, 5, -120);  // Start in open area south of city

        // Thrust works like real acro:
        // - Thrust vector points "up" from the drone's perspective
        // - Pitch forward = thrust tilts forward = drone accelerates forward
        // - At hover, ~40% throttle counters gravity

        // --- 3. GAME STATE ---
        const gameState = {
            mode: 'freefly',        // 'freefly' | 'countdown' | 'racing' | 'crashed'
            raceStartTime: 0,
            currentLapTime: 0,
            currentGate: 0,
            totalGates: 0,
            lapTimes: [],
            bestLap: null
        };

        // Load best lap from localStorage
        const savedBestLap = localStorage.getItem('fpv_best_lap');
        if (savedBestLap) gameState.bestLap = parseFloat(savedBestLap);

        // --- 4. CAMERA CONTROLLER ---
        const cameraController = {
            offset: new THREE.Vector3(0, 0.12, 0.35),  // Front of drone, between front props
            tiltAngle: 15,      // Camera tilt in degrees (positive = tilted up)
            minTilt: -10,       // Min tilt (looking down)
            maxTilt: 45,        // Max tilt (looking up, for fast forward flight)
        };

        // --- 5. THEME & UI ---
        const body = document.body;
        const themeBtn = document.getElementById('theme-toggle');

        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            body.classList.add('dark-mode');
        }
        themeBtn.addEventListener('click', () => body.classList.toggle('dark-mode'));

        function showNotification(msg) {
            const area = document.getElementById('notification-area');
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.innerText = msg;
            area.appendChild(toast);
            setTimeout(() => { toast.style.opacity = '0'; setTimeout(() => toast.remove(), 300); }, 3000);
        }

        // --- 6. THREE.JS SCENE SETUP ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();

        // Create sky dome for static background
        const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
        const skyCanvas = document.createElement('canvas');
        skyCanvas.width = 1024;
        skyCanvas.height = 1024;
        const skyCtx = skyCanvas.getContext('2d');

        // Gradient from top to bottom
        const skyGradient = skyCtx.createLinearGradient(0, 0, 0, 1024);
        skyGradient.addColorStop(0, '#1565C0');      // Deep blue at top
        skyGradient.addColorStop(0.15, '#1976D2');   // Royal blue
        skyGradient.addColorStop(0.3, '#42A5F5');    // Light blue
        skyGradient.addColorStop(0.5, '#64B5F6');    // Sky blue
        skyGradient.addColorStop(0.7, '#90CAF9');    // Powder blue
        skyGradient.addColorStop(0.85, '#BBDEFB');   // Very light blue
        skyGradient.addColorStop(1, '#E3F2FD');      // Almost white at horizon
        skyCtx.fillStyle = skyGradient;
        skyCtx.fillRect(0, 0, 1024, 1024);

        const skyTexture = new THREE.CanvasTexture(skyCanvas);
        const skyMaterial = new THREE.MeshBasicMaterial({
            map: skyTexture,
            side: THREE.BackSide
        });
        const skyDome = new THREE.Mesh(skyGeometry, skyMaterial);
        scene.add(skyDome);

        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0xBBDEFB, 150, 500);

        const camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
        camera.position.set(0, 5, -120);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        container.appendChild(renderer.domElement);

        // Lighting - Ambient
        const ambientLight = new THREE.AmbientLight(0x87CEEB, 0.4);
        scene.add(ambientLight);

        // Hemisphere light for natural sky/ground lighting
        const hemiLight = new THREE.HemisphereLight(0x87CEEB, 0x3d8c40, 0.3);
        scene.add(hemiLight);

        // Sun light (directional)
        const sunLight = new THREE.DirectionalLight(0xfffaf0, 1.2);
        sunLight.position.set(100, 150, 80);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 4096;
        sunLight.shadow.mapSize.height = 4096;
        sunLight.shadow.camera.near = 10;
        sunLight.shadow.camera.far = 500;
        sunLight.shadow.camera.left = -150;
        sunLight.shadow.camera.right = 150;
        sunLight.shadow.camera.top = 150;
        sunLight.shadow.camera.bottom = -150;
        scene.add(sunLight);

        // Visible Sun sphere
        const sunGeom = new THREE.SphereGeometry(15, 32, 32);
        const sunMat = new THREE.MeshBasicMaterial({
            color: 0xffff80,
            transparent: true,
            opacity: 0.95
        });
        const sunMesh = new THREE.Mesh(sunGeom, sunMat);
        sunMesh.position.set(100, 150, 80);
        scene.add(sunMesh);

        // Sun glow
        const sunGlowGeom = new THREE.SphereGeometry(25, 32, 32);
        const sunGlowMat = new THREE.MeshBasicMaterial({
            color: 0xffffcc,
            transparent: true,
            opacity: 0.3
        });
        const sunGlow = new THREE.Mesh(sunGlowGeom, sunGlowMat);
        sunGlow.position.copy(sunMesh.position);
        scene.add(sunGlow);

        // --- 7. GROUND PLANE WITH GRASS TEXTURE ---
        const groundSize = 400;

        // Create procedural grass texture
        const grassCanvas = document.createElement('canvas');
        grassCanvas.width = 512;
        grassCanvas.height = 512;
        const grassCtx = grassCanvas.getContext('2d');

        // Base green
        grassCtx.fillStyle = '#3a7d32';
        grassCtx.fillRect(0, 0, 512, 512);

        // Add grass variation
        for (let i = 0; i < 10000; i++) {
            const x = Math.random() * 512;
            const y = Math.random() * 512;
            const shade = Math.random() * 50 - 25;
            const g = Math.floor(125 + shade);
            grassCtx.fillStyle = `rgb(${45 + Math.random() * 25}, ${g}, ${35 + Math.random() * 25})`;
            grassCtx.fillRect(x, y, 1 + Math.random() * 3, 1 + Math.random() * 3);
        }

        // Add some darker patches
        for (let i = 0; i < 80; i++) {
            const x = Math.random() * 512;
            const y = Math.random() * 512;
            grassCtx.fillStyle = 'rgba(30, 80, 30, 0.25)';
            grassCtx.beginPath();
            grassCtx.arc(x, y, 8 + Math.random() * 25, 0, Math.PI * 2);
            grassCtx.fill();
        }

        const grassTexture = new THREE.CanvasTexture(grassCanvas);
        grassTexture.wrapS = THREE.RepeatWrapping;
        grassTexture.wrapT = THREE.RepeatWrapping;
        grassTexture.repeat.set(60, 60);

        const groundGeom = new THREE.PlaneGeometry(groundSize, groundSize);
        const groundMat = new THREE.MeshStandardMaterial({
            map: grassTexture,
            roughness: 0.85
        });
        const ground = new THREE.Mesh(groundGeom, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = 0;
        ground.receiveShadow = true;
        scene.add(ground);

        // --- 7b. 3D GRASS BLADES AND GRASS CLUMPS ---
        const grassBladeMaterials = [
            new THREE.MeshStandardMaterial({ color: 0x3a7d32, side: THREE.DoubleSide }),
            new THREE.MeshStandardMaterial({ color: 0x4a8d42, side: THREE.DoubleSide }),
            new THREE.MeshStandardMaterial({ color: 0x2d6b27, side: THREE.DoubleSide }),
            new THREE.MeshStandardMaterial({ color: 0x5a9d52, side: THREE.DoubleSide }),
            new THREE.MeshStandardMaterial({ color: 0x3d8b35, side: THREE.DoubleSide }),
            new THREE.MeshStandardMaterial({ color: 0x4d9d45, side: THREE.DoubleSide })
        ];

        // Create grass clumps (groups of blades)
        function createGrassClump(x, z, density = 5) {
            const clumpGroup = new THREE.Group();
            for (let i = 0; i < density; i++) {
                const bladeHeight = 0.3 + Math.random() * 0.5;
                const bladeGeom = new THREE.PlaneGeometry(0.08 + Math.random() * 0.06, bladeHeight);
                const blade = new THREE.Mesh(
                    bladeGeom,
                    grassBladeMaterials[Math.floor(Math.random() * grassBladeMaterials.length)]
                );
                blade.position.set(
                    (Math.random() - 0.5) * 0.5,
                    bladeHeight / 2,
                    (Math.random() - 0.5) * 0.5
                );
                blade.rotation.y = Math.random() * Math.PI;
                blade.rotation.x = -0.15 + Math.random() * 0.3;
                clumpGroup.add(blade);
            }
            clumpGroup.position.set(x, 0, z);
            scene.add(clumpGroup);
        }

        // Dense grass everywhere except city center and streets
        for (let i = 0; i < 8000; i++) {
            const x = (Math.random() - 0.5) * groundSize * 0.95;
            const z = (Math.random() - 0.5) * groundSize * 0.95;

            // Skip city center
            if (Math.abs(x) < 85 && Math.abs(z) < 85) continue;
            // Skip train track area
            if (z > 85 && z < 95) continue;

            const density = 3 + Math.floor(Math.random() * 5);
            createGrassClump(x, z, density);
        }

        // Extra dense grass near spawn area
        for (let i = 0; i < 2000; i++) {
            const x = (Math.random() - 0.5) * 60;
            const z = -120 + (Math.random() - 0.5) * 40;
            createGrassClump(x, z, 4 + Math.floor(Math.random() * 4));
        }

        // Tall grass / wild grass patches
        const tallGrassMat = new THREE.MeshStandardMaterial({ color: 0x6b8e23, side: THREE.DoubleSide });
        for (let i = 0; i < 500; i++) {
            const x = (Math.random() - 0.5) * groundSize * 0.9;
            const z = (Math.random() - 0.5) * groundSize * 0.9;
            if (Math.abs(x) < 90 && Math.abs(z) < 90) continue;

            const tallGrass = new THREE.Mesh(
                new THREE.PlaneGeometry(0.15, 0.8 + Math.random() * 0.4),
                tallGrassMat
            );
            tallGrass.position.set(x, 0.4, z);
            tallGrass.rotation.y = Math.random() * Math.PI;
            tallGrass.rotation.x = Math.random() * 0.2;
            scene.add(tallGrass);
        }

        // --- 8. DRONE MODEL ---
        const droneGroup = new THREE.Group();
        const propellers = [];

        // Body
        const matBody = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.4, metalness: 0.6 });
        const matArm = new THREE.MeshStandardMaterial({ color: 0x2196F3, roughness: 0.5, metalness: 0.3 });
        const matProp = new THREE.MeshStandardMaterial({ color: 0xdddddd, transparent: true, opacity: 0.6 });

        const bodyMesh = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.15, 0.3), matBody);
        bodyMesh.castShadow = true;
        droneGroup.add(bodyMesh);

        // Arms (X shape)
        const arm1 = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.05, 1.8), matArm);
        arm1.rotation.y = Math.PI / 4;
        arm1.castShadow = true;
        const arm2 = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.05, 1.8), matArm);
        arm2.rotation.y = -Math.PI / 4;
        arm2.castShadow = true;
        droneGroup.add(arm1);
        droneGroup.add(arm2);

        // Propellers
        const propPositions = [
            { x: -0.6, z: 0.6 }, { x: 0.6, z: -0.6 },
            { x: 0.6, z: 0.6 }, { x: -0.6, z: -0.6 }
        ];
        propPositions.forEach((pos, i) => {
            const prop = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.35, 0.02, 16), matProp);
            prop.position.set(pos.x, 0.08, pos.z);
            propellers.push(prop);
            droneGroup.add(prop);
        });

        droneGroup.position.copy(physics.position);
        scene.add(droneGroup);

        // --- 9. GATES REMOVED - FREE FLIGHT MODE ---
        const gates = [];  // Empty for compatibility

        // --- 10. CITY AND ENVIRONMENT ---
        const buildings = [];
        const trees = [];

        // ============================================
        // CITY AREA - NEW YORK STYLE GRID SYSTEM
        // ============================================

        // City configuration
        const cityConfig = {
            blocksX: 5,           // 5x5 grid = ~20x20 blocks area
            blocksZ: 5,
            blockSize: 35,        // Size of each block
            mainRoadWidth: 14,    // Two-way roads with barrier
            sideRoadWidth: 8,     // Single two-way roads
            sidewalkWidth: 3,
            greenGapWidth: 2,
            droneGap: 3           // Minimum gap between buildings for flying
        };

        // Materials
        const roofMat = new THREE.MeshStandardMaterial({ color: 0x3a3a3a, roughness: 0.9 });
        const streetMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.9 });
        const sidewalkMat = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.7 });
        const greenGapMat = new THREE.MeshStandardMaterial({ color: 0x3d6b3d, roughness: 0.9 });
        const barrierMat = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.8 });
        const yellowLineMat = new THREE.MeshStandardMaterial({ color: 0xffdd00 });
        const whiteLineMat = new THREE.MeshStandardMaterial({ color: 0xffffff });

        // Building colors - all slightly different
        const buildingColors = [
            0x8b7355, 0x9c8b7a, 0x7a6b5a, 0xa09080, 0x6b5b4a,  // Browns/tans
            0x708090, 0x778899, 0x696969, 0x808080, 0x5f6a6a,  // Grays/slates
            0xb8a090, 0xc4b8a8, 0xd4c8b8, 0xa89888, 0x987858,  // Beiges
            0x4a5568, 0x5a6578, 0x6a7588, 0x7a8598, 0x8a95a8   // Blue-grays
        ];

        // Hotel/Building names
        const buildingNames = [
            "WALDORF", "RITZ", "PLAZA", "GRAND", "ROYAL", "IMPERIAL",
            "CARLTON", "SAVOY", "MAJESTIC", "REGENT", "CROWN", "PALACE",
            "ASTORIA", "BRISTOL", "CLARIDGE", "DORCHESTER", "EXCELSIOR"
        ];
        let nameIndex = 0;

        // Window colors
        const windowColors = [0x88ccff, 0x99ddff, 0xaaddee, 0x77bbee, 0x66aadd];

        // Super tower glass material
        const superGlassMat = new THREE.MeshStandardMaterial({
            color: 0x88ddff,
            roughness: 0.05,
            metalness: 0.95,
            transparent: true,
            opacity: 0.9
        });

        // Create a named building with roof elements
        function createCityBuilding(x, z, width, depth, height, colorIndex, hasWindows = true) {
            const buildingGroup = new THREE.Group();
            const color = buildingColors[colorIndex % buildingColors.length];
            const mat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.7 });

            // Main structure
            const building = new THREE.Mesh(new THREE.BoxGeometry(width, height, depth), mat);
            building.position.y = height / 2;
            building.castShadow = true;
            building.receiveShadow = true;
            buildingGroup.add(building);

            // Windows with varying sizes and colors
            if (hasWindows && height > 10) {
                const windowColor = windowColors[Math.floor(Math.random() * windowColors.length)];
                const windowMat = new THREE.MeshStandardMaterial({
                    color: windowColor,
                    roughness: 0.1,
                    metalness: 0.9
                });
                const windowWidth = 1.2 + Math.random() * 0.8;
                const windowHeight = 1.8 + Math.random() * 0.6;
                const windowSpacingX = windowWidth + 1.5 + Math.random();
                const windowSpacingY = windowHeight + 1.5 + Math.random();

                const windowRows = Math.floor((height - 4) / windowSpacingY);
                const windowColsFront = Math.floor((width - 2) / windowSpacingX);
                const windowColsSide = Math.floor((depth - 2) / windowSpacingX);

                // Front and back windows
                for (let row = 0; row < windowRows; row++) {
                    for (let col = 0; col < windowColsFront; col++) {
                        const windowMesh = new THREE.Mesh(
                            new THREE.PlaneGeometry(windowWidth, windowHeight),
                            windowMat
                        );
                        windowMesh.position.set(
                            -width/2 + 1.5 + col * windowSpacingX,
                            3 + row * windowSpacingY,
                            depth/2 + 0.05
                        );
                        buildingGroup.add(windowMesh);

                        const backWindow = windowMesh.clone();
                        backWindow.position.z = -depth/2 - 0.05;
                        backWindow.rotation.y = Math.PI;
                        buildingGroup.add(backWindow);
                    }
                }

                // Side windows
                for (let row = 0; row < windowRows; row++) {
                    for (let col = 0; col < windowColsSide; col++) {
                        const windowMesh = new THREE.Mesh(
                            new THREE.PlaneGeometry(windowWidth, windowHeight),
                            windowMat
                        );
                        windowMesh.rotation.y = Math.PI / 2;
                        windowMesh.position.set(
                            width/2 + 0.05,
                            3 + row * windowSpacingY,
                            -depth/2 + 1.5 + col * windowSpacingX
                        );
                        buildingGroup.add(windowMesh);

                        const otherSide = windowMesh.clone();
                        otherSide.position.x = -width/2 - 0.05;
                        otherSide.rotation.y = -Math.PI / 2;
                        buildingGroup.add(otherSide);
                    }
                }
            }

            // Roof access door (always add for logic)
            const doorMat = new THREE.MeshStandardMaterial({ color: 0x4a4a4a });
            const roofDoor = new THREE.Mesh(new THREE.BoxGeometry(2, 3, 2), doorMat);
            roofDoor.position.set(0, height + 1.5, 0);
            roofDoor.castShadow = true;
            buildingGroup.add(roofDoor);

            // Random roof elements
            const roofElement = Math.floor(Math.random() * 5);
            const metalMat = new THREE.MeshStandardMaterial({ color: 0x666666, metalness: 0.8, roughness: 0.3 });

            if (roofElement === 0 && width > 10 && depth > 10) {
                // AC units
                for (let i = 0; i < 2 + Math.floor(Math.random() * 3); i++) {
                    const ac = new THREE.Mesh(new THREE.BoxGeometry(2, 1.5, 2), metalMat);
                    ac.position.set(
                        (Math.random() - 0.5) * (width - 4),
                        height + 0.75,
                        (Math.random() - 0.5) * (depth - 4)
                    );
                    buildingGroup.add(ac);
                }
            } else if (roofElement === 1) {
                // Antenna
                const antenna = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 8, 8), metalMat);
                antenna.position.set(width/4, height + 4, depth/4);
                buildingGroup.add(antenna);
            } else if (roofElement === 2 && width > 12 && depth > 12) {
                // Helipad
                const helipadMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
                const helipad = new THREE.Mesh(new THREE.CylinderGeometry(4, 4, 0.2, 16), helipadMat);
                helipad.position.set(0, height + 0.1, 0);
                buildingGroup.add(helipad);
                // H marking
                const hMat = new THREE.MeshStandardMaterial({ color: 0xffff00 });
                const hBar = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.05, 2.5), hMat);
                hBar.position.set(0, height + 0.25, 0);
                buildingGroup.add(hBar);
            } else if (roofElement === 3) {
                // Telescope/observatory dome
                const dome = new THREE.Mesh(new THREE.SphereGeometry(2, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2), metalMat);
                dome.position.set(0, height, 0);
                buildingGroup.add(dome);
            } else {
                // Water tank
                const tank = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.5, 3, 12), metalMat);
                tank.position.set(width/3, height + 1.5, -depth/3);
                buildingGroup.add(tank);
            }

            // Building name sign
            const name = buildingNames[nameIndex % buildingNames.length];
            nameIndex++;

            buildingGroup.position.set(x, 0, z);
            scene.add(buildingGroup);

            return {
                position: new THREE.Vector3(x, 0, z),
                width: width,
                depth: depth,
                height: height
            };
        }

        // Create the Super Tower (111 West 57th Street style)
        function createSuperTower(x, z) {
            const buildingGroup = new THREE.Group();
            const towerWidth = 12;
            const towerDepth = 12;
            const towerHeight = 180;

            // Main glass tower
            const tower = new THREE.Mesh(
                new THREE.BoxGeometry(towerWidth, towerHeight, towerDepth),
                superGlassMat
            );
            tower.position.y = towerHeight / 2;
            tower.castShadow = true;
            buildingGroup.add(tower);

            // Window grid lines (dark frames)
            const frameMat = new THREE.MeshStandardMaterial({ color: 0x222222 });

            // Vertical frames
            for (let i = -towerWidth/2 + 2; i <= towerWidth/2 - 2; i += 2) {
                const vFrame = new THREE.Mesh(new THREE.BoxGeometry(0.1, towerHeight, 0.2), frameMat);
                vFrame.position.set(i, towerHeight/2, towerDepth/2 + 0.1);
                buildingGroup.add(vFrame);
                const vFrameBack = vFrame.clone();
                vFrameBack.position.z = -towerDepth/2 - 0.1;
                buildingGroup.add(vFrameBack);
            }

            // Horizontal frames
            for (let h = 4; h < towerHeight; h += 4) {
                const hFrame = new THREE.Mesh(new THREE.BoxGeometry(towerWidth + 0.2, 0.1, 0.2), frameMat);
                hFrame.position.set(0, h, towerDepth/2 + 0.1);
                buildingGroup.add(hFrame);
                const hFrameBack = hFrame.clone();
                hFrameBack.position.z = -towerDepth/2 - 0.1;
                buildingGroup.add(hFrameBack);
            }

            // Spire on top
            const spire = new THREE.Mesh(
                new THREE.CylinderGeometry(0.3, 1, 20, 8),
                new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.9 })
            );
            spire.position.y = towerHeight + 10;
            buildingGroup.add(spire);

            // Roof access
            const doorMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const roofDoor = new THREE.Mesh(new THREE.BoxGeometry(3, 4, 3), doorMat);
            roofDoor.position.set(3, towerHeight + 2, 3);
            buildingGroup.add(roofDoor);

            buildingGroup.position.set(x, 0, z);
            scene.add(buildingGroup);

            return {
                position: new THREE.Vector3(x, 0, z),
                width: towerWidth,
                depth: towerDepth,
                height: towerHeight + 20
            };
        }

        // Create petrol station
        function createPetrolStation(x, z) {
            const group = new THREE.Group();

            // Base platform
            const baseMat = new THREE.MeshStandardMaterial({ color: 0x555555 });
            const base = new THREE.Mesh(new THREE.BoxGeometry(20, 0.3, 15), baseMat);
            base.position.y = 0.15;
            group.add(base);

            // Canopy (loopable roof)
            const canopyMat = new THREE.MeshStandardMaterial({ color: 0xdd0000 });
            const canopy = new THREE.Mesh(new THREE.BoxGeometry(18, 0.5, 12), canopyMat);
            canopy.position.y = 5;
            group.add(canopy);

            // Canopy supports
            const supportMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.8 });
            const supportPositions = [[-7, 4], [7, 4], [-7, -4], [7, -4]];
            supportPositions.forEach(([sx, sz]) => {
                const support = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 5, 8), supportMat);
                support.position.set(sx, 2.5, sz);
                group.add(support);
            });

            // Fuel pumps
            const pumpMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee });
            for (let i = -1; i <= 1; i += 2) {
                const pump = new THREE.Mesh(new THREE.BoxGeometry(1, 2.5, 0.8), pumpMat);
                pump.position.set(i * 4, 1.25, 0);
                group.add(pump);
            }

            // Small shop building
            const shopMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const shop = new THREE.Mesh(new THREE.BoxGeometry(8, 4, 6), shopMat);
            shop.position.set(0, 2, -7);
            group.add(shop);

            group.position.set(x, 0, z);
            scene.add(group);

            return { position: new THREE.Vector3(x, 0, z), width: 20, depth: 15, height: 5.5 };
        }

        // Create church
        function createChurch(x, z) {
            const group = new THREE.Group();
            const churchMat = new THREE.MeshStandardMaterial({ color: 0xd4c8b8 });
            const roofChurchMat = new THREE.MeshStandardMaterial({ color: 0x4a3728 });

            // Main building
            const main = new THREE.Mesh(new THREE.BoxGeometry(12, 10, 20), churchMat);
            main.position.y = 5;
            main.castShadow = true;
            group.add(main);

            // Roof
            const roof = new THREE.Mesh(
                new THREE.ConeGeometry(10, 5, 4),
                roofChurchMat
            );
            roof.rotation.y = Math.PI / 4;
            roof.position.y = 12.5;
            group.add(roof);

            // Bell tower
            const tower = new THREE.Mesh(new THREE.BoxGeometry(5, 20, 5), churchMat);
            tower.position.set(0, 10, -10);
            tower.castShadow = true;
            group.add(tower);

            // Steeple
            const steeple = new THREE.Mesh(new THREE.ConeGeometry(3.5, 8, 4), roofChurchMat);
            steeple.rotation.y = Math.PI / 4;
            steeple.position.set(0, 24, -10);
            group.add(steeple);

            // Cross
            const crossMat = new THREE.MeshStandardMaterial({ color: 0xffd700 });
            const crossV = new THREE.Mesh(new THREE.BoxGeometry(0.3, 3, 0.3), crossMat);
            crossV.position.set(0, 29.5, -10);
            group.add(crossV);
            const crossH = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.3, 0.3), crossMat);
            crossH.position.set(0, 30, -10);
            group.add(crossH);

            // Stained glass windows
            const glassMat = new THREE.MeshStandardMaterial({ color: 0x8844aa, roughness: 0.2 });
            for (let i = -1; i <= 1; i++) {
                const window = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 4), glassMat);
                window.position.set(6.05, 5, i * 5);
                window.rotation.y = Math.PI / 2;
                group.add(window);
            }

            group.position.set(x, 0, z);
            scene.add(group);

            return { position: new THREE.Vector3(x, 0, z), width: 12, depth: 25, height: 32 };
        }

        // Create construction site
        function createConstructionSite(x, z) {
            const group = new THREE.Group();

            // Unfinished building frame
            const frameMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.8 });
            const concreteMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });

            // Concrete floors
            for (let floor = 0; floor < 5; floor++) {
                const slab = new THREE.Mesh(new THREE.BoxGeometry(18, 0.5, 18), concreteMat);
                slab.position.y = floor * 4 + 0.25;
                group.add(slab);
            }

            // Steel frame columns
            const columnPositions = [[-8, -8], [-8, 8], [8, -8], [8, 8], [0, -8], [0, 8], [-8, 0], [8, 0]];
            columnPositions.forEach(([cx, cz]) => {
                const column = new THREE.Mesh(new THREE.BoxGeometry(0.8, 20, 0.8), frameMat);
                column.position.set(cx, 10, cz);
                group.add(column);
            });

            // Tower crane
            const craneMat = new THREE.MeshStandardMaterial({ color: 0xffcc00 });

            // Crane tower
            const craneTower = new THREE.Mesh(new THREE.BoxGeometry(2, 35, 2), craneMat);
            craneTower.position.set(-12, 17.5, -12);
            group.add(craneTower);

            // Crane arm
            const craneArm = new THREE.Mesh(new THREE.BoxGeometry(30, 1, 1), craneMat);
            craneArm.position.set(-12 + 10, 35, -12);
            group.add(craneArm);

            // Counter weight arm
            const counterArm = new THREE.Mesh(new THREE.BoxGeometry(10, 1, 1), craneMat);
            counterArm.position.set(-12 - 7, 35, -12);
            group.add(counterArm);

            // Counter weight
            const weight = new THREE.Mesh(new THREE.BoxGeometry(3, 3, 2), new THREE.MeshStandardMaterial({ color: 0x333333 }));
            weight.position.set(-12 - 10, 33.5, -12);
            group.add(weight);

            // Safety fence
            const fenceMat = new THREE.MeshStandardMaterial({ color: 0xff6600, transparent: true, opacity: 0.8 });
            const fencePositions = [
                { x: 0, z: 11, rx: 0, ry: 0, w: 24 },
                { x: 0, z: -11, rx: 0, ry: 0, w: 24 },
                { x: 11, z: 0, rx: 0, ry: Math.PI/2, w: 22 },
                { x: -11, z: 0, rx: 0, ry: Math.PI/2, w: 22 }
            ];
            fencePositions.forEach(fp => {
                const fence = new THREE.Mesh(new THREE.PlaneGeometry(fp.w, 2.5), fenceMat);
                fence.position.set(fp.x, 1.25, fp.z);
                fence.rotation.y = fp.ry;
                group.add(fence);
            });

            group.position.set(x, 0, z);
            scene.add(group);

            return { position: new THREE.Vector3(x, 0, z), width: 24, depth: 24, height: 36 };
        }

        // Create mini park
        function createMiniPark(x, z) {
            const group = new THREE.Group();

            // Grass ground
            const parkGrass = new THREE.Mesh(
                new THREE.PlaneGeometry(25, 25),
                new THREE.MeshStandardMaterial({ color: 0x4a8b4a })
            );
            parkGrass.rotation.x = -Math.PI / 2;
            parkGrass.position.y = 0.02;
            group.add(parkGrass);

            // Iron fence around park
            const fenceMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.8 });
            const fenceHeight = 1.5;

            for (let side = 0; side < 4; side++) {
                for (let i = -11; i <= 11; i += 2) {
                    const post = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, fenceHeight, 6), fenceMat);
                    if (side === 0) post.position.set(i, fenceHeight/2, 12);
                    else if (side === 1) post.position.set(i, fenceHeight/2, -12);
                    else if (side === 2) post.position.set(12, fenceHeight/2, i);
                    else post.position.set(-12, fenceHeight/2, i);
                    group.add(post);
                }
            }

            // Playground equipment - Slide
            const slideMat = new THREE.MeshStandardMaterial({ color: 0xff4444 });
            const slide = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.1, 5), slideMat);
            slide.rotation.x = Math.PI / 6;
            slide.position.set(-5, 1.5, 0);
            group.add(slide);

            // Slide ladder
            const ladderMat = new THREE.MeshStandardMaterial({ color: 0x888888 });
            const ladder = new THREE.Mesh(new THREE.BoxGeometry(1.5, 3, 0.3), ladderMat);
            ladder.position.set(-5, 1.5, -3);
            group.add(ladder);

            // Swings frame
            const swingFrame = new THREE.Mesh(new THREE.BoxGeometry(0.2, 4, 0.2), ladderMat);
            swingFrame.position.set(5, 2, -2);
            group.add(swingFrame);
            const swingFrame2 = swingFrame.clone();
            swingFrame2.position.set(5, 2, 2);
            group.add(swingFrame2);
            const swingTop = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 4.5), ladderMat);
            swingTop.position.set(5, 4, 0);
            group.add(swingTop);

            // Swing seats
            const seatMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
            const seat = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.1, 0.4), seatMat);
            seat.position.set(5, 1, 0);
            group.add(seat);

            // Bench
            const benchMat = new THREE.MeshStandardMaterial({ color: 0x654321 });
            const benchSeat = new THREE.Mesh(new THREE.BoxGeometry(3, 0.2, 0.8), benchMat);
            benchSeat.position.set(0, 0.6, 8);
            group.add(benchSeat);

            group.position.set(x, 0, z);
            scene.add(group);

            return { position: new THREE.Vector3(x, 0, z), width: 25, depth: 25, height: 4 };
        }

        // Track placed buildings to avoid overlap
        const placedBuildings = [];

        function checkOverlap(x, z, width, depth, gap) {
            for (const b of placedBuildings) {
                const dx = Math.abs(x - b.x);
                const dz = Math.abs(z - b.z);
                if (dx < (width + b.width) / 2 + gap && dz < (depth + b.depth) / 2 + gap) {
                    return true;
                }
            }
            return false;
        }

        function registerBuilding(x, z, width, depth) {
            placedBuildings.push({ x, z, width, depth });
        }

        // City area bounds
        const cityMinX = -100, cityMaxX = 100;
        const cityMinZ = -100, cityMaxZ = 100;
        const citySize = cityMaxX - cityMinX;

        // Create main roads (two-way with barrier)
        const mainRoadPositions = [-50, 0, 50];
        mainRoadPositions.forEach(pos => {
            // Horizontal main road
            const hRoad = new THREE.Mesh(
                new THREE.PlaneGeometry(citySize, cityConfig.mainRoadWidth),
                streetMat
            );
            hRoad.rotation.x = -Math.PI / 2;
            hRoad.position.set(0, 0.02, pos);
            hRoad.receiveShadow = true;
            scene.add(hRoad);

            // Center barrier
            for (let bx = cityMinX + 5; bx < cityMaxX; bx += 10) {
                const barrier = new THREE.Mesh(new THREE.BoxGeometry(8, 0.4, 0.5), barrierMat);
                barrier.position.set(bx, 0.2, pos);
                scene.add(barrier);
            }

            // Yellow center lines
            for (let lx = cityMinX; lx < cityMaxX; lx += 8) {
                const line = new THREE.Mesh(new THREE.PlaneGeometry(5, 0.3), yellowLineMat);
                line.rotation.x = -Math.PI / 2;
                line.position.set(lx, 0.03, pos - 0.5);
                scene.add(line);
                const line2 = line.clone();
                line2.position.z = pos + 0.5;
                scene.add(line2);
            }

            // Vertical main road
            const vRoad = new THREE.Mesh(
                new THREE.PlaneGeometry(cityConfig.mainRoadWidth, citySize),
                streetMat
            );
            vRoad.rotation.x = -Math.PI / 2;
            vRoad.position.set(pos, 0.02, 0);
            vRoad.receiveShadow = true;
            scene.add(vRoad);

            // Center barrier for vertical
            for (let bz = cityMinZ + 5; bz < cityMaxZ; bz += 10) {
                if (Math.abs(bz - 0) > 10 && Math.abs(bz - 50) > 10 && Math.abs(bz + 50) > 10) {
                    const barrier = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.4, 8), barrierMat);
                    barrier.position.set(pos, 0.2, bz);
                    scene.add(barrier);
                }
            }
        });

        // Create side roads
        const sideRoadPositions = [-75, -25, 25, 75];
        sideRoadPositions.forEach(pos => {
            // Horizontal side road
            const hRoad = new THREE.Mesh(
                new THREE.PlaneGeometry(citySize, cityConfig.sideRoadWidth),
                streetMat
            );
            hRoad.rotation.x = -Math.PI / 2;
            hRoad.position.set(0, 0.02, pos);
            scene.add(hRoad);

            // Vertical side road
            const vRoad = new THREE.Mesh(
                new THREE.PlaneGeometry(cityConfig.sideRoadWidth, citySize),
                streetMat
            );
            vRoad.rotation.x = -Math.PI / 2;
            vRoad.position.set(pos, 0.02, 0);
            scene.add(vRoad);
        });

        // Create sidewalks and green gaps along main roads
        mainRoadPositions.forEach(pos => {
            const sidewalkOffset = cityConfig.mainRoadWidth / 2 + cityConfig.greenGapWidth + cityConfig.sidewalkWidth / 2;
            const greenOffset = cityConfig.mainRoadWidth / 2 + cityConfig.greenGapWidth / 2;

            // Both sides - horizontal
            [-1, 1].forEach(side => {
                // Green gap
                const greenGap = new THREE.Mesh(
                    new THREE.PlaneGeometry(citySize, cityConfig.greenGapWidth),
                    greenGapMat
                );
                greenGap.rotation.x = -Math.PI / 2;
                greenGap.position.set(0, 0.015, pos + side * greenOffset);
                scene.add(greenGap);

                // Sidewalk
                const sidewalk = new THREE.Mesh(
                    new THREE.PlaneGeometry(citySize, cityConfig.sidewalkWidth),
                    sidewalkMat
                );
                sidewalk.rotation.x = -Math.PI / 2;
                sidewalk.position.set(0, 0.025, pos + side * sidewalkOffset);
                scene.add(sidewalk);
            });

            // Both sides - vertical
            [-1, 1].forEach(side => {
                const greenGap = new THREE.Mesh(
                    new THREE.PlaneGeometry(cityConfig.greenGapWidth, citySize),
                    greenGapMat
                );
                greenGap.rotation.x = -Math.PI / 2;
                greenGap.position.set(pos + side * greenOffset, 0.015, 0);
                scene.add(greenGap);

                const sidewalk = new THREE.Mesh(
                    new THREE.PlaneGeometry(cityConfig.sidewalkWidth, citySize),
                    sidewalkMat
                );
                sidewalk.rotation.x = -Math.PI / 2;
                sidewalk.position.set(pos + side * sidewalkOffset, 0.025, 0);
                scene.add(sidewalk);
            });
        });

        // Place the Super Tower in the center
        buildings.push(createSuperTower(0, 0));
        registerBuilding(0, 0, 15, 15);

        // Place special buildings (spread around, never adjacent)
        const specialLocations = [
            { x: -70, z: -70 },
            { x: 70, z: 70 },
            { x: -70, z: 70 },
            { x: 70, z: -70 },
            { x: -35, z: 35 },
            { x: 35, z: -35 }
        ];

        // Petrol stations (2)
        buildings.push(createPetrolStation(specialLocations[0].x, specialLocations[0].z));
        registerBuilding(specialLocations[0].x, specialLocations[0].z, 22, 17);
        buildings.push(createPetrolStation(specialLocations[1].x, specialLocations[1].z));
        registerBuilding(specialLocations[1].x, specialLocations[1].z, 22, 17);

        // Churches (2)
        buildings.push(createChurch(specialLocations[2].x, specialLocations[2].z));
        registerBuilding(specialLocations[2].x, specialLocations[2].z, 14, 27);
        buildings.push(createChurch(specialLocations[3].x, specialLocations[3].z));
        registerBuilding(specialLocations[3].x, specialLocations[3].z, 14, 27);

        // Construction sites (2)
        buildings.push(createConstructionSite(specialLocations[4].x, specialLocations[4].z));
        registerBuilding(specialLocations[4].x, specialLocations[4].z, 26, 26);
        buildings.push(createConstructionSite(specialLocations[5].x, specialLocations[5].z));
        registerBuilding(specialLocations[5].x, specialLocations[5].z, 26, 26);

        // Mini parks (3)
        const parkLocations = [
            { x: -35, z: -70 },
            { x: 35, z: 70 },
            { x: 0, z: -35 }
        ];
        parkLocations.forEach(loc => {
            createMiniPark(loc.x, loc.z);
            registerBuilding(loc.x, loc.z, 27, 27);
        });

        // Fill remaining blocks with regular buildings
        let buildingColorIdx = 0;
        for (let bx = cityMinX + 20; bx < cityMaxX - 15; bx += 25) {
            for (let bz = cityMinZ + 20; bz < cityMaxZ - 15; bz += 25) {
                // Skip if near roads
                let nearRoad = false;
                mainRoadPositions.forEach(rp => {
                    if (Math.abs(bx - rp) < 15 || Math.abs(bz - rp) < 15) nearRoad = true;
                });
                sideRoadPositions.forEach(rp => {
                    if (Math.abs(bx - rp) < 10 || Math.abs(bz - rp) < 10) nearRoad = true;
                });
                if (nearRoad) continue;

                // Random building size with drone gap consideration
                const width = 8 + Math.random() * 8;
                const depth = 8 + Math.random() * 8;
                const height = 15 + Math.random() * 40;

                // Add some offset for variety
                const offsetX = (Math.random() - 0.5) * 5;
                const offsetZ = (Math.random() - 0.5) * 5;
                const finalX = bx + offsetX;
                const finalZ = bz + offsetZ;

                if (!checkOverlap(finalX, finalZ, width, depth, cityConfig.droneGap)) {
                    buildings.push(createCityBuilding(finalX, finalZ, width, depth, height, buildingColorIdx, true));
                    registerBuilding(finalX, finalZ, width, depth);
                    buildingColorIdx++;
                }
            }
        }

        // --- 10b. CARS ---
        const carColors = [0xff0000, 0x0000ff, 0x00ff00, 0xffff00, 0xffffff, 0x000000, 0xff8800];

        function createCar(x, z, rotation) {
            const carGroup = new THREE.Group();
            const color = carColors[Math.floor(Math.random() * carColors.length)];
            const carMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.3, metalness: 0.8 });

            // Body
            const body = new THREE.Mesh(new THREE.BoxGeometry(2, 0.8, 4), carMat);
            body.position.y = 0.6;
            body.castShadow = true;
            carGroup.add(body);

            // Cabin
            const cabin = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.7, 2), glassMat);
            cabin.position.y = 1.3;
            cabin.position.z = -0.3;
            carGroup.add(cabin);

            // Wheels
            const wheelGeom = new THREE.CylinderGeometry(0.35, 0.35, 0.3, 16);
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
            const wheelPositions = [
                { x: -1, z: 1.2 }, { x: 1, z: 1.2 },
                { x: -1, z: -1.2 }, { x: 1, z: -1.2 }
            ];
            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeom, wheelMat);
                wheel.rotation.z = Math.PI / 2;
                wheel.position.set(pos.x, 0.35, pos.z);
                carGroup.add(wheel);
            });

            carGroup.position.set(x, 0, z);
            carGroup.rotation.y = rotation;
            scene.add(carGroup);
        }

        // Place cars along streets
        for (let i = 0; i < 30; i++) {
            const streetZ = [-60, -20, 20, 60][Math.floor(Math.random() * 4)];
            const x = (Math.random() - 0.5) * 140;
            createCar(x, streetZ + (Math.random() - 0.5) * 4, Math.random() > 0.5 ? 0 : Math.PI);
        }

        // --- 10c. TRAIN AND TRACKS ---
        // Train tracks
        const trackMat = new THREE.MeshStandardMaterial({ color: 0x4a4a4a });
        const railMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.8 });

        const trackZ = 90;
        // Track bed
        const trackBed = new THREE.Mesh(new THREE.BoxGeometry(groundSize * 0.8, 0.5, 6), trackMat);
        trackBed.position.set(0, 0.25, trackZ);
        trackBed.receiveShadow = true;
        scene.add(trackBed);

        // Rails
        for (let offset of [-1.5, 1.5]) {
            const rail = new THREE.Mesh(new THREE.BoxGeometry(groundSize * 0.8, 0.2, 0.3), railMat);
            rail.position.set(0, 0.6, trackZ + offset);
            scene.add(rail);
        }

        // Train
        const trainGroup = new THREE.Group();
        const trainMat = new THREE.MeshStandardMaterial({ color: 0xcc0000, roughness: 0.5 });

        // Locomotive body - width along X (direction of travel), depth along Z
        const locomotive = new THREE.Mesh(new THREE.BoxGeometry(14, 4.5, 4), trainMat);
        locomotive.position.set(0, 2.75, 0);
        locomotive.castShadow = true;
        trainGroup.add(locomotive);

        // Locomotive cab (rear section)
        const cab = new THREE.Mesh(new THREE.BoxGeometry(4, 3, 3.5), trainMat);
        cab.position.set(-5, 4.5, 0);
        cab.castShadow = true;
        trainGroup.add(cab);

        // Train front nose
        const trainFront = new THREE.Mesh(new THREE.BoxGeometry(3, 3.5, 3.5), trainMat);
        trainFront.position.set(8, 2.25, 0);
        trainGroup.add(trainFront);

        // Wheels (cylinders under locomotive)
        const wheelMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.8 });
        for (let wx of [-4, 0, 4]) {
            const wheel = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 4.5, 12), wheelMat);
            wheel.rotation.x = Math.PI / 2;
            wheel.position.set(wx, 1, 0);
            trainGroup.add(wheel);
        }

        // Carriages
        const carriageMat = new THREE.MeshStandardMaterial({ color: 0x2255aa });
        const carriageWindowMat = new THREE.MeshStandardMaterial({ color: 0x88ccff, metalness: 0.3 });
        for (let i = 0; i < 4; i++) {
            const carriageGroup = new THREE.Group();

            const carriage = new THREE.Mesh(new THREE.BoxGeometry(12, 4, 3.5), carriageMat);
            carriage.position.set(0, 2.5, 0);
            carriage.castShadow = true;
            carriageGroup.add(carriage);

            // Carriage roof
            const roof = new THREE.Mesh(new THREE.BoxGeometry(11, 0.5, 3), carriageMat);
            roof.position.set(0, 4.75, 0);
            carriageGroup.add(roof);

            // Carriage wheels
            for (let cwx of [-3, 3]) {
                const cwheel = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.8, 4, 12), wheelMat);
                cwheel.rotation.x = Math.PI / 2;
                cwheel.position.set(cwx, 0.8, 0);
                carriageGroup.add(cwheel);
            }

            carriageGroup.position.set(-16 - i * 14, 0, 0);
            trainGroup.add(carriageGroup);
        }

        // Position train on track - Y at 0 so wheels sit on rails
        trainGroup.position.set(-100, 0, trackZ);
        scene.add(trainGroup);

        // Train collision data (bounding box that moves with train)
        const trainCollision = {
            length: 75,  // Total train length
            width: 4,    // Width of train
            height: 6,   // Height of train
            offsetX: -20 // Center offset (train extends more backward)
        };

        // Animate train
        let trainX = -100;
        function updateTrain(dt) {
            trainX += 20 * dt;  // Slightly faster
            if (trainX > groundSize / 2 + 50) trainX = -groundSize / 2 - 50;
            trainGroup.position.x = trainX;
        }

        // Train collision check function
        function checkTrainCollision() {
            // Get train center position
            const trainCenterX = trainGroup.position.x + trainCollision.offsetX;
            const trainZ = trainGroup.position.z;

            const dx = physics.position.x - trainCenterX;
            const dz = physics.position.z - trainZ;

            // Check if within train's bounding box
            if (Math.abs(dx) < trainCollision.length / 2 + physics.droneRadius &&
                Math.abs(dz) < trainCollision.width / 2 + physics.droneRadius &&
                physics.position.y < trainCollision.height) {
                return true;
            }
            return false;
        }

        // --- 10d. STREET FURNITURE (City area) ---

        // Street light
        function createStreetLight(x, z, rotation = 0) {
            const group = new THREE.Group();
            const poleMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.7 });
            const lightMat = new THREE.MeshStandardMaterial({ color: 0xffffcc, emissive: 0xffff88, emissiveIntensity: 0.3 });

            // Pole
            const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.15, 6, 8), poleMat);
            pole.position.y = 3;
            group.add(pole);

            // Arm extending over road
            const arm = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 2, 8), poleMat);
            arm.rotation.z = Math.PI / 2;
            arm.position.set(1, 5.8, 0);
            group.add(arm);

            // Light fixture
            const fixture = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.3, 0.4), poleMat);
            fixture.position.set(1.8, 5.6, 0);
            group.add(fixture);

            // Light bulb (glowing)
            const bulb = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 8), lightMat);
            bulb.position.set(1.8, 5.4, 0);
            group.add(bulb);

            group.position.set(x, 0, z);
            group.rotation.y = rotation;
            scene.add(group);
        }

        // Rubbish bin
        function createRubbishBin(x, z) {
            const group = new THREE.Group();
            const binMat = new THREE.MeshStandardMaterial({ color: 0x2a4a2a });

            const bin = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.35, 1, 12), binMat);
            bin.position.y = 0.5;
            group.add(bin);

            // Lid
            const lid = new THREE.Mesh(new THREE.CylinderGeometry(0.45, 0.45, 0.1, 12), binMat);
            lid.position.y = 1.05;
            group.add(lid);

            group.position.set(x, 0, z);
            scene.add(group);
        }

        // Street sign with garbled text
        function createStreetSign(x, z, rotation = 0) {
            const group = new THREE.Group();
            const poleMat = new THREE.MeshStandardMaterial({ color: 0x666666, metalness: 0.7 });
            const signMat = new THREE.MeshStandardMaterial({ color: 0x225522 });

            // Pole (thin, flyable gap below sign)
            const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 3.5, 8), poleMat);
            pole.position.y = 1.75;
            group.add(pole);

            // Sign (high enough to fly under)
            const sign = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.6, 0.1), signMat);
            sign.position.y = 3.8;
            group.add(sign);

            // White border
            const borderMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const border = new THREE.Mesh(new THREE.BoxGeometry(2.6, 0.7, 0.08), borderMat);
            border.position.y = 3.8;
            border.position.z = -0.02;
            group.add(border);

            group.position.set(x, 0, z);
            group.rotation.y = rotation;
            scene.add(group);
        }

        // Advertisement billboard on building
        function createAdvertisement(x, y, z, rotation = 0, width = 8, height = 4) {
            const group = new THREE.Group();
            const colors = [0xff4444, 0x4444ff, 0x44ff44, 0xffff44, 0xff44ff];
            const adMat = new THREE.MeshStandardMaterial({
                color: colors[Math.floor(Math.random() * colors.length)],
                emissive: 0x222222,
                emissiveIntensity: 0.2
            });

            const board = new THREE.Mesh(new THREE.BoxGeometry(width, height, 0.3), adMat);
            board.position.y = y;
            group.add(board);

            // Frame
            const frameMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const frameT = new THREE.Mesh(new THREE.BoxGeometry(width + 0.4, 0.2, 0.4), frameMat);
            frameT.position.y = y + height/2;
            group.add(frameT);
            const frameB = frameT.clone();
            frameB.position.y = y - height/2;
            group.add(frameB);

            group.position.set(x, 0, z);
            group.rotation.y = rotation;
            scene.add(group);
        }

        // Place street lights along sidewalks (not touching buildings)
        mainRoadPositions.forEach(roadPos => {
            const sidewalkOffset = cityConfig.mainRoadWidth / 2 + cityConfig.greenGapWidth + cityConfig.sidewalkWidth / 2;

            // Along horizontal roads
            for (let lx = cityMinX + 15; lx < cityMaxX - 10; lx += 30) {
                // Check not at intersection
                let atIntersection = false;
                mainRoadPositions.forEach(rp => { if (Math.abs(lx - rp) < 10) atIntersection = true; });
                sideRoadPositions.forEach(rp => { if (Math.abs(lx - rp) < 8) atIntersection = true; });
                if (atIntersection) continue;

                createStreetLight(lx, roadPos + sidewalkOffset, 0);
                createStreetLight(lx, roadPos - sidewalkOffset, Math.PI);
            }

            // Along vertical roads
            for (let lz = cityMinZ + 15; lz < cityMaxZ - 10; lz += 30) {
                let atIntersection = false;
                mainRoadPositions.forEach(rp => { if (Math.abs(lz - rp) < 10) atIntersection = true; });
                sideRoadPositions.forEach(rp => { if (Math.abs(lz - rp) < 8) atIntersection = true; });
                if (atIntersection) continue;

                createStreetLight(roadPos + sidewalkOffset, lz, -Math.PI/2);
                createStreetLight(roadPos - sidewalkOffset, lz, Math.PI/2);
            }
        });

        // Place rubbish bins on sidewalks and green gaps
        for (let i = 0; i < 40; i++) {
            const onMainRoad = Math.random() > 0.5;
            const roadPos = onMainRoad
                ? mainRoadPositions[Math.floor(Math.random() * mainRoadPositions.length)]
                : sideRoadPositions[Math.floor(Math.random() * sideRoadPositions.length)];

            const offset = (onMainRoad ? cityConfig.mainRoadWidth : cityConfig.sideRoadWidth) / 2 + 1 + Math.random() * 2;
            const side = Math.random() > 0.5 ? 1 : -1;
            const horizontal = Math.random() > 0.5;

            const bx = horizontal ? (Math.random() - 0.5) * citySize * 0.8 : roadPos + side * offset;
            const bz = horizontal ? roadPos + side * offset : (Math.random() - 0.5) * citySize * 0.8;

            // Only place in city area
            if (Math.abs(bx) < 95 && Math.abs(bz) < 95) {
                createRubbishBin(bx, bz);
            }
        }

        // Place street signs at intersections
        mainRoadPositions.forEach(mx => {
            sideRoadPositions.forEach(sz => {
                if (Math.random() > 0.5) {
                    createStreetSign(mx + 8, sz + 5, 0);
                }
            });
        });
        sideRoadPositions.forEach(sx => {
            mainRoadPositions.forEach(mz => {
                if (Math.random() > 0.5) {
                    createStreetSign(sx + 5, mz + 8, Math.PI/2);
                }
            });
        });

        // Place advertisements on some buildings (buildings without many windows)
        for (let i = 0; i < 15; i++) {
            const bx = (Math.random() - 0.5) * 150;
            const bz = (Math.random() - 0.5) * 150;
            const height = 10 + Math.random() * 20;
            const rotation = Math.random() * Math.PI * 2;

            // Only in city area
            if (Math.abs(bx) < 90 && Math.abs(bz) < 90) {
                createAdvertisement(bx, height, bz, rotation, 6 + Math.random() * 4, 3 + Math.random() * 2);
            }
        }

        // Safety cones ONLY outside city area (along track)
        const coneMat = new THREE.MeshStandardMaterial({ color: 0xFF6600 });
        const coneStripeMat = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });

        function createSafetyCone(x, z) {
            const coneGroup = new THREE.Group();
            const cone = new THREE.Mesh(new THREE.ConeGeometry(0.4, 1.2, 8), coneMat);
            cone.position.y = 0.6;
            coneGroup.add(cone);

            const stripe = new THREE.Mesh(new THREE.TorusGeometry(0.25, 0.05, 8, 16), coneStripeMat);
            stripe.rotation.x = Math.PI / 2;
            stripe.position.y = 0.8;
            coneGroup.add(stripe);

            const base = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.1, 0.8), coneMat);
            base.position.y = 0.05;
            coneGroup.add(base);

            coneGroup.position.set(x, 0, z);
            scene.add(coneGroup);
        }

        // Cones only along train track (outside city)
        for (let x = -150; x <= 150; x += 20) {
            createSafetyCone(x, trackZ - 5);
            createSafetyCone(x, trackZ + 5);
        }

        // --- 10e. MANY DIFFERENT TREE TYPES ---
        const treeTrunkMat = new THREE.MeshStandardMaterial({ color: 0x4a3728 });
        const birchTrunkMat = new THREE.MeshStandardMaterial({ color: 0xe8e4d9 });
        const willowTrunkMat = new THREE.MeshStandardMaterial({ color: 0x5c4a32 });

        // Pine tree
        function createPineTree(x, z, scale = 1) {
            const treeGroup = new THREE.Group();
            const trunkHeight = 5 * scale;
            const trunk = new THREE.Mesh(
                new THREE.CylinderGeometry(0.3 * scale, 0.5 * scale, trunkHeight, 8),
                treeTrunkMat
            );
            trunk.position.y = trunkHeight / 2;
            trunk.castShadow = true;
            treeGroup.add(trunk);

            const foliageColors = [0x1a4d1a, 0x2d5a27, 0x1f5f1f];
            for (let i = 0; i < 5; i++) {
                const radius = (4 - i * 0.7) * scale;
                const foliage = new THREE.Mesh(
                    new THREE.ConeGeometry(radius, 3 * scale, 8),
                    new THREE.MeshStandardMaterial({ color: foliageColors[i % 3] })
                );
                foliage.position.y = trunkHeight - 1 + i * 1.5 * scale;
                foliage.castShadow = true;
                treeGroup.add(foliage);
            }
            treeGroup.position.set(x, 0, z);
            scene.add(treeGroup);
            return { position: new THREE.Vector3(x, 0, z), radius: 1.5 * scale, height: trunkHeight + 8 * scale };
        }

        // Oak tree (round foliage)
        function createOakTree(x, z, scale = 1) {
            const treeGroup = new THREE.Group();
            const trunkHeight = 4 * scale;
            const trunk = new THREE.Mesh(
                new THREE.CylinderGeometry(0.4 * scale, 0.6 * scale, trunkHeight, 8),
                treeTrunkMat
            );
            trunk.position.y = trunkHeight / 2;
            trunk.castShadow = true;
            treeGroup.add(trunk);

            const foliageMat = new THREE.MeshStandardMaterial({ color: 0x3a7d32 });
            for (let i = 0; i < 6; i++) {
                const foliage = new THREE.Mesh(
                    new THREE.SphereGeometry(2.5 * scale + Math.random(), 8, 6),
                    foliageMat
                );
                foliage.position.set(
                    (Math.random() - 0.5) * 3 * scale,
                    trunkHeight + 1 + Math.random() * 2 * scale,
                    (Math.random() - 0.5) * 3 * scale
                );
                foliage.castShadow = true;
                treeGroup.add(foliage);
            }
            treeGroup.position.set(x, 0, z);
            scene.add(treeGroup);
            return { position: new THREE.Vector3(x, 0, z), radius: 2 * scale, height: trunkHeight + 6 * scale };
        }

        // Palm tree
        function createPalmTree(x, z, scale = 1) {
            const treeGroup = new THREE.Group();
            const trunkHeight = 8 * scale;
            for (let i = 0; i < 8; i++) {
                const segment = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3 * scale, 0.35 * scale, trunkHeight / 8, 8),
                    new THREE.MeshStandardMaterial({ color: 0x8b7355 })
                );
                segment.position.y = i * trunkHeight / 8 + trunkHeight / 16;
                segment.position.x = Math.sin(i * 0.1) * 0.3;
                segment.castShadow = true;
                treeGroup.add(segment);
            }
            const frondMat = new THREE.MeshStandardMaterial({ color: 0x228b22, side: THREE.DoubleSide });
            for (let i = 0; i < 8; i++) {
                const frond = new THREE.Mesh(new THREE.PlaneGeometry(1 * scale, 5 * scale), frondMat);
                frond.position.y = trunkHeight;
                frond.rotation.y = (i / 8) * Math.PI * 2;
                frond.rotation.x = -0.8;
                treeGroup.add(frond);
            }
            treeGroup.position.set(x, 0, z);
            scene.add(treeGroup);
            return { position: new THREE.Vector3(x, 0, z), radius: 1 * scale, height: trunkHeight + 2 * scale };
        }

        // Birch tree (white bark, yellow-green leaves)
        function createBirchTree(x, z, scale = 1) {
            const treeGroup = new THREE.Group();
            const trunkHeight = 6 * scale;
            const trunk = new THREE.Mesh(
                new THREE.CylinderGeometry(0.2 * scale, 0.3 * scale, trunkHeight, 8),
                birchTrunkMat
            );
            trunk.position.y = trunkHeight / 2;
            trunk.castShadow = true;
            treeGroup.add(trunk);

            const foliageMat = new THREE.MeshStandardMaterial({ color: 0x90b050 });
            for (let i = 0; i < 4; i++) {
                const foliage = new THREE.Mesh(
                    new THREE.SphereGeometry(1.8 * scale + Math.random() * 0.5, 8, 6),
                    foliageMat
                );
                foliage.position.set(
                    (Math.random() - 0.5) * 2 * scale,
                    trunkHeight - 1 + i * 1.2 * scale,
                    (Math.random() - 0.5) * 2 * scale
                );
                foliage.castShadow = true;
                treeGroup.add(foliage);
            }
            treeGroup.position.set(x, 0, z);
            scene.add(treeGroup);
            return { position: new THREE.Vector3(x, 0, z), radius: 1.5 * scale, height: trunkHeight + 5 * scale };
        }

        // Willow tree (drooping branches)
        function createWillowTree(x, z, scale = 1) {
            const treeGroup = new THREE.Group();
            const trunkHeight = 5 * scale;
            const trunk = new THREE.Mesh(
                new THREE.CylinderGeometry(0.5 * scale, 0.7 * scale, trunkHeight, 8),
                willowTrunkMat
            );
            trunk.position.y = trunkHeight / 2;
            trunk.castShadow = true;
            treeGroup.add(trunk);

            // Drooping foliage
            const foliageMat = new THREE.MeshStandardMaterial({ color: 0x5a8a32, side: THREE.DoubleSide });
            for (let i = 0; i < 12; i++) {
                const droop = new THREE.Mesh(
                    new THREE.PlaneGeometry(0.5 * scale, 4 * scale),
                    foliageMat
                );
                const angle = (i / 12) * Math.PI * 2;
                droop.position.set(
                    Math.cos(angle) * 2 * scale,
                    trunkHeight - 1,
                    Math.sin(angle) * 2 * scale
                );
                droop.rotation.y = angle;
                droop.rotation.x = 0.5;
                treeGroup.add(droop);
            }
            // Top canopy
            const canopy = new THREE.Mesh(
                new THREE.SphereGeometry(3 * scale, 8, 6),
                foliageMat
            );
            canopy.position.y = trunkHeight + 1;
            canopy.scale.y = 0.6;
            canopy.castShadow = true;
            treeGroup.add(canopy);

            treeGroup.position.set(x, 0, z);
            scene.add(treeGroup);
            return { position: new THREE.Vector3(x, 0, z), radius: 2.5 * scale, height: trunkHeight + 4 * scale };
        }

        // Cypress tree (tall and narrow)
        function createCypressTree(x, z, scale = 1) {
            const treeGroup = new THREE.Group();
            const trunkHeight = 2 * scale;
            const trunk = new THREE.Mesh(
                new THREE.CylinderGeometry(0.2 * scale, 0.3 * scale, trunkHeight, 8),
                treeTrunkMat
            );
            trunk.position.y = trunkHeight / 2;
            trunk.castShadow = true;
            treeGroup.add(trunk);

            const foliageMat = new THREE.MeshStandardMaterial({ color: 0x2d4a1a });
            const foliage = new THREE.Mesh(
                new THREE.ConeGeometry(1.5 * scale, 10 * scale, 8),
                foliageMat
            );
            foliage.position.y = trunkHeight + 5 * scale;
            foliage.castShadow = true;
            treeGroup.add(foliage);

            treeGroup.position.set(x, 0, z);
            scene.add(treeGroup);
            return { position: new THREE.Vector3(x, 0, z), radius: 1 * scale, height: trunkHeight + 10 * scale };
        }

        // Maple tree (spreading branches)
        function createMapleTree(x, z, scale = 1) {
            const treeGroup = new THREE.Group();
            const trunkHeight = 3.5 * scale;
            const trunk = new THREE.Mesh(
                new THREE.CylinderGeometry(0.35 * scale, 0.5 * scale, trunkHeight, 8),
                treeTrunkMat
            );
            trunk.position.y = trunkHeight / 2;
            trunk.castShadow = true;
            treeGroup.add(trunk);

            const foliageColors = [0x8b2500, 0xcd3700, 0xff4500, 0x3a7d32];
            const color = foliageColors[Math.floor(Math.random() * foliageColors.length)];
            const foliageMat = new THREE.MeshStandardMaterial({ color: color });

            for (let i = 0; i < 8; i++) {
                const foliage = new THREE.Mesh(
                    new THREE.SphereGeometry(2 * scale + Math.random() * 0.8, 8, 6),
                    foliageMat
                );
                foliage.position.set(
                    (Math.random() - 0.5) * 4 * scale,
                    trunkHeight + Math.random() * 3 * scale,
                    (Math.random() - 0.5) * 4 * scale
                );
                foliage.castShadow = true;
                treeGroup.add(foliage);
            }
            treeGroup.position.set(x, 0, z);
            scene.add(treeGroup);
            return { position: new THREE.Vector3(x, 0, z), radius: 2.5 * scale, height: trunkHeight + 6 * scale };
        }

        // Bush / shrub
        function createBush(x, z, scale = 1) {
            const bushGroup = new THREE.Group();
            const bushColors = [0x3a7d32, 0x4a8d42, 0x2d6b27, 0x5a9d52];
            const color = bushColors[Math.floor(Math.random() * bushColors.length)];
            const bushMat = new THREE.MeshStandardMaterial({ color: color });

            for (let i = 0; i < 4; i++) {
                const sphere = new THREE.Mesh(
                    new THREE.SphereGeometry(0.8 * scale + Math.random() * 0.4, 8, 6),
                    bushMat
                );
                sphere.position.set(
                    (Math.random() - 0.5) * scale,
                    0.6 * scale,
                    (Math.random() - 0.5) * scale
                );
                sphere.castShadow = true;
                bushGroup.add(sphere);
            }
            bushGroup.position.set(x, 0, z);
            scene.add(bushGroup);
            return { position: new THREE.Vector3(x, 0, z), radius: 1 * scale, height: 1.5 * scale };
        }

        const edgeOffset = groundSize / 2 - 20;

        // Very dense forest at edges (500+ trees)
        for (let i = 0; i < 500; i++) {
            const angle = Math.random() * Math.PI * 2;
            const dist = edgeOffset - 20 + Math.random() * 40;
            const x = Math.cos(angle) * dist;
            const z = Math.sin(angle) * dist;
            const scale = 0.5 + Math.random() * 1.0;
            const type = Math.random();

            if (type < 0.25) {
                trees.push(createPineTree(x, z, scale));
            } else if (type < 0.45) {
                trees.push(createOakTree(x, z, scale));
            } else if (type < 0.55) {
                trees.push(createBirchTree(x, z, scale));
            } else if (type < 0.65) {
                trees.push(createWillowTree(x, z, scale));
            } else if (type < 0.75) {
                trees.push(createCypressTree(x, z, scale));
            } else if (type < 0.85) {
                trees.push(createMapleTree(x, z, scale));
            } else if (type < 0.92) {
                trees.push(createPalmTree(x, z, scale));
            } else {
                trees.push(createBush(x, z, scale));
            }
        }

        // Park trees (200+ more between city and edges)
        for (let i = 0; i < 200; i++) {
            const x = (Math.random() - 0.5) * groundSize * 0.7;
            const z = (Math.random() - 0.5) * groundSize * 0.7;
            if (Math.abs(x) < 85 && Math.abs(z) < 85) continue;
            if (z > 80 && z < 100) continue; // Skip train track
            const scale = 0.6 + Math.random() * 0.7;
            const type = Math.random();

            if (type < 0.3) trees.push(createOakTree(x, z, scale));
            else if (type < 0.5) trees.push(createPineTree(x, z, scale));
            else if (type < 0.65) trees.push(createBirchTree(x, z, scale));
            else if (type < 0.8) trees.push(createMapleTree(x, z, scale));
            else trees.push(createBush(x, z, scale * 0.8));
        }

        // Trees near spawn area
        for (let i = 0; i < 50; i++) {
            const x = (Math.random() - 0.5) * 80;
            const z = -140 + Math.random() * 30;
            const scale = 0.6 + Math.random() * 0.6;
            if (Math.random() > 0.5) trees.push(createOakTree(x, z, scale));
            else trees.push(createBirchTree(x, z, scale));
        }

        // Bushes scattered around
        for (let i = 0; i < 150; i++) {
            const x = (Math.random() - 0.5) * groundSize * 0.85;
            const z = (Math.random() - 0.5) * groundSize * 0.85;
            if (Math.abs(x) < 90 && Math.abs(z) < 90) continue;
            trees.push(createBush(x, z, 0.6 + Math.random() * 0.6));
        }

        // --- CITY GREEN GAP TREES AND GRASS ---
        // Track placed city trees to prevent overlap
        const cityTreePositions = [];

        function canPlaceCityTree(x, z, radius) {
            // Check against buildings
            for (const b of placedBuildings) {
                const dx = Math.abs(x - b.x);
                const dz = Math.abs(z - b.z);
                if (dx < b.width / 2 + radius + 2 && dz < b.depth / 2 + radius + 2) {
                    return false;
                }
            }
            // Check against other city trees
            for (const t of cityTreePositions) {
                const dx = x - t.x;
                const dz = z - t.z;
                if (Math.sqrt(dx * dx + dz * dz) < radius + t.radius + 1) {
                    return false;
                }
            }
            return true;
        }

        // Place trees along green gaps (main roads)
        mainRoadPositions.forEach(roadPos => {
            const greenOffset = cityConfig.mainRoadWidth / 2 + cityConfig.greenGapWidth / 2;

            // Trees along horizontal roads
            for (let tx = cityMinX + 10; tx < cityMaxX - 10; tx += 8 + Math.random() * 6) {
                [-1, 1].forEach(side => {
                    const treeZ = roadPos + side * greenOffset;
                    const treeX = tx + (Math.random() - 0.5) * 3;

                    // Skip intersections
                    let atIntersection = false;
                    mainRoadPositions.forEach(rp => { if (Math.abs(treeX - rp) < 12) atIntersection = true; });
                    sideRoadPositions.forEach(rp => { if (Math.abs(treeX - rp) < 8) atIntersection = true; });
                    if (atIntersection) return;

                    if (canPlaceCityTree(treeX, treeZ, 1.5)) {
                        const scale = 0.4 + Math.random() * 0.3;
                        const type = Math.random();
                        if (type < 0.3) trees.push(createOakTree(treeX, treeZ, scale));
                        else if (type < 0.5) trees.push(createMapleTree(treeX, treeZ, scale));
                        else if (type < 0.7) trees.push(createBirchTree(treeX, treeZ, scale));
                        else trees.push(createBush(treeX, treeZ, scale * 0.8));
                        cityTreePositions.push({ x: treeX, z: treeZ, radius: 1.5 * scale });
                    }
                });
            }

            // Trees along vertical roads
            for (let tz = cityMinZ + 10; tz < cityMaxZ - 10; tz += 8 + Math.random() * 6) {
                [-1, 1].forEach(side => {
                    const treeX = roadPos + side * greenOffset;
                    const treeZ = tz + (Math.random() - 0.5) * 3;

                    let atIntersection = false;
                    mainRoadPositions.forEach(rp => { if (Math.abs(treeZ - rp) < 12) atIntersection = true; });
                    sideRoadPositions.forEach(rp => { if (Math.abs(treeZ - rp) < 8) atIntersection = true; });
                    if (atIntersection) return;

                    if (canPlaceCityTree(treeX, treeZ, 1.5)) {
                        const scale = 0.4 + Math.random() * 0.3;
                        const type = Math.random();
                        if (type < 0.3) trees.push(createOakTree(treeX, treeZ, scale));
                        else if (type < 0.5) trees.push(createMapleTree(treeX, treeZ, scale));
                        else if (type < 0.7) trees.push(createBirchTree(treeX, treeZ, scale));
                        else trees.push(createBush(treeX, treeZ, scale * 0.8));
                        cityTreePositions.push({ x: treeX, z: treeZ, radius: 1.5 * scale });
                    }
                });
            }
        });

        // 3D grass in green gaps
        const cityGrassMat = new THREE.MeshStandardMaterial({
            color: 0x4a8b4a,
            roughness: 0.9,
            side: THREE.DoubleSide
        });

        function createCityGrassClump(x, z) {
            const group = new THREE.Group();
            const numBlades = 3 + Math.floor(Math.random() * 4);

            for (let i = 0; i < numBlades; i++) {
                const bladeHeight = 0.15 + Math.random() * 0.2;
                const blade = new THREE.Mesh(
                    new THREE.PlaneGeometry(0.05, bladeHeight),
                    cityGrassMat
                );
                blade.position.set(
                    (Math.random() - 0.5) * 0.15,
                    bladeHeight / 2,
                    (Math.random() - 0.5) * 0.15
                );
                blade.rotation.y = Math.random() * Math.PI;
                blade.rotation.x = (Math.random() - 0.5) * 0.3;
                group.add(blade);
            }

            group.position.set(x, 0, z);
            scene.add(group);
        }

        // Place grass along green gaps
        mainRoadPositions.forEach(roadPos => {
            const greenOffset = cityConfig.mainRoadWidth / 2 + cityConfig.greenGapWidth / 2;

            // Grass along horizontal green gaps
            for (let gx = cityMinX + 2; gx < cityMaxX - 2; gx += 1.5 + Math.random()) {
                [-1, 1].forEach(side => {
                    const gz = roadPos + side * greenOffset + (Math.random() - 0.5) * cityConfig.greenGapWidth * 0.8;
                    // Skip if near a tree
                    let nearTree = false;
                    for (const t of cityTreePositions) {
                        if (Math.abs(gx - t.x) < t.radius + 0.5 && Math.abs(gz - t.z) < t.radius + 0.5) {
                            nearTree = true;
                            break;
                        }
                    }
                    if (!nearTree && Math.random() > 0.3) {
                        createCityGrassClump(gx, gz);
                    }
                });
            }

            // Grass along vertical green gaps
            for (let gz = cityMinZ + 2; gz < cityMaxZ - 2; gz += 1.5 + Math.random()) {
                [-1, 1].forEach(side => {
                    const gx = roadPos + side * greenOffset + (Math.random() - 0.5) * cityConfig.greenGapWidth * 0.8;
                    let nearTree = false;
                    for (const t of cityTreePositions) {
                        if (Math.abs(gx - t.x) < t.radius + 0.5 && Math.abs(gz - t.z) < t.radius + 0.5) {
                            nearTree = true;
                            break;
                        }
                    }
                    if (!nearTree && Math.random() > 0.3) {
                        createCityGrassClump(gx, gz);
                    }
                });
            }
        });

        // --- 10f. VARIED CLOUDS ---
        const clouds = [];

        function createCloud(x, y, z, type = 'normal') {
            const cloudGroup = new THREE.Group();
            const cloudMat = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: type === 'wispy' ? 0.6 : 0.85,
                roughness: 1
            });

            let numPuffs, puffSize, spread;

            let vertical = 1;

            switch(type) {
                case 'large':
                    numPuffs = 12 + Math.floor(Math.random() * 8);
                    puffSize = 15;
                    spread = 50;
                    break;
                case 'wispy':
                    numPuffs = 3 + Math.floor(Math.random() * 3);
                    puffSize = 6;
                    spread = 40;
                    cloudMat.opacity = 0.5;
                    break;
                case 'storm':
                    numPuffs = 20 + Math.floor(Math.random() * 10);
                    puffSize = 20;
                    spread = 60;
                    cloudMat.color.setHex(0xaaaaaa);
                    break;
                case 'towering':
                    numPuffs = 15 + Math.floor(Math.random() * 10);
                    puffSize = 18;
                    spread = 35;
                    vertical = 2.5;
                    break;
                case 'flat':
                    numPuffs = 8 + Math.floor(Math.random() * 6);
                    puffSize = 12;
                    spread = 70;
                    vertical = 0.3;
                    cloudMat.opacity = 0.7;
                    break;
                case 'puffy':
                    numPuffs = 6 + Math.floor(Math.random() * 4);
                    puffSize = 14;
                    spread = 25;
                    break;
                default:
                    numPuffs = 5 + Math.floor(Math.random() * 5);
                    puffSize = 10;
                    spread = 30;
            }

            for (let i = 0; i < numPuffs; i++) {
                const size = puffSize * (0.5 + Math.random());
                const puff = new THREE.Mesh(
                    new THREE.SphereGeometry(size, 8, 6),
                    cloudMat
                );
                puff.position.set(
                    (Math.random() - 0.5) * spread,
                    (Math.random() - 0.5) * (puffSize * vertical),
                    (Math.random() - 0.5) * (spread * 0.5)
                );
                puff.scale.y = (0.5 + Math.random() * 0.3) * (vertical > 1 ? 1.5 : 1);
                cloudGroup.add(puff);
            }

            cloudGroup.position.set(x, y, z);

            const cloudData = {
                group: cloudGroup,
                baseY: y,
                speedX: (Math.random() - 0.5) * 3,
                speedZ: (Math.random() - 0.5) * 1.5,
                bobSpeed: 0.3 + Math.random() * 0.4,
                bobAmount: 1 + Math.random() * 2,
                phase: Math.random() * Math.PI * 2,
                rotationSpeed: (Math.random() - 0.5) * 0.02
            };

            scene.add(cloudGroup);
            return cloudData;
        }

        // Create massive cloud coverage
        // Normal fluffy clouds - 60 clouds
        for (let i = 0; i < 60; i++) {
            const x = (Math.random() - 0.5) * groundSize * 2.5;
            const y = 65 + Math.random() * 45;
            const z = (Math.random() - 0.5) * groundSize * 2.5;
            clouds.push(createCloud(x, y, z, 'normal'));
        }
        // Large cumulus clouds - 30 clouds
        for (let i = 0; i < 30; i++) {
            const x = (Math.random() - 0.5) * groundSize * 2.5;
            const y = 90 + Math.random() * 60;
            const z = (Math.random() - 0.5) * groundSize * 2.5;
            clouds.push(createCloud(x, y, z, 'large'));
        }
        // Wispy cirrus clouds - 40 clouds
        for (let i = 0; i < 40; i++) {
            const x = (Math.random() - 0.5) * groundSize * 2.5;
            const y = 55 + Math.random() * 35;
            const z = (Math.random() - 0.5) * groundSize * 2.5;
            clouds.push(createCloud(x, y, z, 'wispy'));
        }
        // Storm clouds - 10 clouds
        for (let i = 0; i < 10; i++) {
            const x = (Math.random() - 0.5) * groundSize * 2;
            const y = 110 + Math.random() * 40;
            const z = (Math.random() - 0.5) * groundSize * 2;
            clouds.push(createCloud(x, y, z, 'storm'));
        }
        // High altitude thin clouds - 25 clouds
        for (let i = 0; i < 25; i++) {
            const x = (Math.random() - 0.5) * groundSize * 3;
            const y = 140 + Math.random() * 50;
            const z = (Math.random() - 0.5) * groundSize * 3;
            clouds.push(createCloud(x, y, z, 'wispy'));
        }
        // Low hanging clouds near city - 20 clouds
        for (let i = 0; i < 20; i++) {
            const x = (Math.random() - 0.5) * groundSize * 1.5;
            const y = 45 + Math.random() * 25;
            const z = (Math.random() - 0.5) * groundSize * 1.5;
            clouds.push(createCloud(x, y, z, 'normal'));
        }
        // Extra large dramatic clouds - 15 clouds
        for (let i = 0; i < 15; i++) {
            const x = (Math.random() - 0.5) * groundSize * 2;
            const y = 100 + Math.random() * 70;
            const z = (Math.random() - 0.5) * groundSize * 2;
            clouds.push(createCloud(x, y, z, 'large'));
        }
        // Scattered small puffs - 50 clouds
        for (let i = 0; i < 50; i++) {
            const x = (Math.random() - 0.5) * groundSize * 2.5;
            const y = 50 + Math.random() * 60;
            const z = (Math.random() - 0.5) * groundSize * 2.5;
            clouds.push(createCloud(x, y, z, 'wispy'));
        }
        // Towering cumulus clouds - 12 clouds
        for (let i = 0; i < 12; i++) {
            const x = (Math.random() - 0.5) * groundSize * 2;
            const y = 80 + Math.random() * 40;
            const z = (Math.random() - 0.5) * groundSize * 2;
            clouds.push(createCloud(x, y, z, 'towering'));
        }
        // Flat stratus clouds - 20 clouds
        for (let i = 0; i < 20; i++) {
            const x = (Math.random() - 0.5) * groundSize * 2.5;
            const y = 55 + Math.random() * 30;
            const z = (Math.random() - 0.5) * groundSize * 2.5;
            clouds.push(createCloud(x, y, z, 'flat'));
        }
        // Puffy cotton-ball clouds - 35 clouds
        for (let i = 0; i < 35; i++) {
            const x = (Math.random() - 0.5) * groundSize * 2;
            const y = 70 + Math.random() * 50;
            const z = (Math.random() - 0.5) * groundSize * 2;
            clouds.push(createCloud(x, y, z, 'puffy'));
        }
        // Very high altitude wisps - 30 clouds
        for (let i = 0; i < 30; i++) {
            const x = (Math.random() - 0.5) * groundSize * 3;
            const y = 180 + Math.random() * 60;
            const z = (Math.random() - 0.5) * groundSize * 3;
            clouds.push(createCloud(x, y, z, 'flat'));
        }

        // Cloud update function
        function updateClouds(dt) {
            const time = performance.now() * 0.001;
            clouds.forEach(cloud => {
                cloud.group.position.x += cloud.speedX * dt;
                cloud.group.position.z += cloud.speedZ * dt;
                cloud.group.position.y = cloud.baseY + Math.sin(time * cloud.bobSpeed + cloud.phase) * cloud.bobAmount;
                cloud.group.rotation.y += cloud.rotationSpeed * dt;

                const limit = groundSize * 1.2;
                if (cloud.group.position.x > limit) cloud.group.position.x = -limit;
                if (cloud.group.position.x < -limit) cloud.group.position.x = limit;
                if (cloud.group.position.z > limit) cloud.group.position.z = -limit;
                if (cloud.group.position.z < -limit) cloud.group.position.z = limit;
            });
        }

        // --- 10g. START/FINISH BANNER ---
        const bannerPoleGeom = new THREE.CylinderGeometry(0.2, 0.2, 8, 8);
        const bannerPoleMat = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });

        const leftBannerPole = new THREE.Mesh(bannerPoleGeom, bannerPoleMat);
        leftBannerPole.position.set(-8, 4, 5);
        leftBannerPole.castShadow = true;
        scene.add(leftBannerPole);

        const rightBannerPole = new THREE.Mesh(bannerPoleGeom, bannerPoleMat);
        rightBannerPole.position.set(8, 4, 5);
        rightBannerPole.castShadow = true;
        scene.add(rightBannerPole);

        // --- 11. COLLISION DETECTION ---
        function checkBuildingCollision() {
            for (const building of buildings) {
                const dx = physics.position.x - building.position.x;
                const dz = physics.position.z - building.position.z;

                // Check if within building's bounding box
                if (Math.abs(dx) < building.width / 2 + physics.droneRadius &&
                    Math.abs(dz) < building.depth / 2 + physics.droneRadius &&
                    physics.position.y < building.height) {
                    return true;
                }
            }
            return false;
        }

        function checkTreeCollision() {
            for (const tree of trees) {
                const dx = physics.position.x - tree.position.x;
                const dz = physics.position.z - tree.position.z;
                const horizontalDist = Math.sqrt(dx * dx + dz * dz);

                // Check if within tree's collision cylinder
                if (horizontalDist < tree.radius + physics.droneRadius &&
                    physics.position.y < tree.height) {
                    return true;
                }
            }
            return false;
        }

        function checkGroundCollision() {
            const groundLevel = 0;
            if (physics.position.y < groundLevel + physics.droneRadius) {
                const impactSpeed = Math.abs(physics.velocity.y);
                if (impactSpeed > 3) {
                    return true; // Crash
                }
                // Soft landing - just stop
                physics.position.y = groundLevel + physics.droneRadius;
                physics.velocity.y = Math.max(0, physics.velocity.y);
            }
            return false;
        }

        function checkGatePass() {
            if (gameState.mode !== 'racing') return;

            const nextGateIndex = gameState.currentGate;
            if (nextGateIndex >= gates.length) return;

            const gate = gates[nextGateIndex];
            const dronePos = physics.position;

            // Check if drone is near the gate plane
            const toGate = new THREE.Vector3().subVectors(dronePos, gate.position);
            const distAlongForward = toGate.dot(gate.forward);

            // Check if crossed the gate plane (from front to back)
            if (Math.abs(distAlongForward) < 2) {
                const lateralDist = Math.sqrt(
                    Math.pow(toGate.x - distAlongForward * gate.forward.x, 2) +
                    Math.pow(toGate.z - distAlongForward * gate.forward.z, 2)
                );
                const heightFromGate = dronePos.y - gate.position.y;

                // Check if within gate bounds
                if (lateralDist < gate.width / 2 &&
                    Math.abs(heightFromGate) < gate.height / 2) {

                    // Gate passed!
                    gate.passed = true;
                    gate.poles.forEach(pole => pole.material = gate.passedMat);
                    gameState.currentGate++;

                    updateGateCounter();

                    if (gameState.currentGate >= gates.length) {
                        // Lap complete!
                        completeLap();
                    } else {
                        showNotification(`Gate ${nextGateIndex + 1} cleared!`);
                    }
                }
            }
        }

        function checkGateCollision() {
            // Simplified: check collision with gate poles
            for (const gate of gates) {
                const dx = physics.position.x - gate.position.x;
                const dy = physics.position.y - gate.position.y;
                const dz = physics.position.z - gate.position.z;

                // Only check if near the gate
                if (Math.abs(dx) > 5 || Math.abs(dz) > 5) continue;

                // Check pole collision (simplified bounding boxes)
                const poleRadius = 0.3;
                const halfWidth = gate.width / 2;

                // Transform drone position to gate local space
                const cosR = Math.cos(-gate.group.rotation.y);
                const sinR = Math.sin(-gate.group.rotation.y);
                const localX = dx * cosR - dz * sinR;
                const localZ = dx * sinR + dz * cosR;

                // Check left pole
                if (Math.abs(localX + halfWidth) < poleRadius + physics.droneRadius &&
                    Math.abs(localZ) < poleRadius + physics.droneRadius &&
                    dy > 0 && dy < gate.height) {
                    return true;
                }
                // Check right pole
                if (Math.abs(localX - halfWidth) < poleRadius + physics.droneRadius &&
                    Math.abs(localZ) < poleRadius + physics.droneRadius &&
                    dy > 0 && dy < gate.height) {
                    return true;
                }
                // Check top bar
                if (Math.abs(dy - gate.height) < poleRadius + physics.droneRadius &&
                    Math.abs(localZ) < poleRadius + physics.droneRadius &&
                    Math.abs(localX) < halfWidth) {
                    return true;
                }
            }
            return false;
        }

        // --- 12. GAME FLOW ---
        function triggerCrash() {
            physics.crashed = true;
            physics.velocity.set(0, 0, 0);
            gameState.mode = 'crashed';
            document.getElementById('crash-overlay').style.display = 'flex';
            showNotification('Crashed! Press R to reset');
        }

        function resetDrone() {
            physics.position.copy(spawnPoint);
            physics.velocity.set(0, 0, 0);
            physics.crashed = false;
            droneGroup.rotation.set(0, 0, 0);
            droneGroup.position.copy(spawnPoint);

            document.getElementById('crash-overlay').style.display = 'none';

            if (gameState.mode === 'crashed' || gameState.mode === 'racing') {
                gameState.mode = 'freefly';
                gameState.currentGate = 0;
                document.getElementById('race-info').style.display = 'none';

                // Reset gate colors
                gates.forEach(gate => {
                    gate.passed = false;
                    gate.poles.forEach(pole => pole.material = gate.poleMat);
                });
            }

            showNotification('Drone reset');
        }

        function startRace() {
            if (gameState.mode !== 'freefly') return;

            resetDrone();
            gameState.mode = 'countdown';

            const countdownOverlay = document.getElementById('countdown-overlay');
            const countdownText = document.getElementById('countdown-text');
            countdownOverlay.style.display = 'flex';

            let count = 3;
            countdownText.textContent = count;

            const countdownInterval = setInterval(() => {
                count--;
                if (count > 0) {
                    countdownText.textContent = count;
                } else if (count === 0) {
                    countdownText.textContent = 'GO!';
                } else {
                    clearInterval(countdownInterval);
                    countdownOverlay.style.display = 'none';
                    gameState.mode = 'racing';
                    gameState.raceStartTime = performance.now();
                    gameState.currentGate = 0;
                    document.getElementById('race-info').style.display = 'block';
                    updateGateCounter();
                }
            }, 1000);
        }

        function completeLap() {
            const lapTime = (performance.now() - gameState.raceStartTime) / 1000;
            gameState.lapTimes.push(lapTime);

            if (!gameState.bestLap || lapTime < gameState.bestLap) {
                gameState.bestLap = lapTime;
                localStorage.setItem('fpv_best_lap', lapTime.toString());
                showNotification(`New best lap: ${formatTime(lapTime)}!`);
            } else {
                showNotification(`Lap complete: ${formatTime(lapTime)}`);
            }

            // Reset for next lap
            gameState.mode = 'freefly';
            gameState.currentGate = 0;
            document.getElementById('race-info').style.display = 'none';

            gates.forEach(gate => {
                gate.passed = false;
                gate.poles.forEach(pole => pole.material = gate.poleMat);
            });

            updateBestLap();
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            const ms = Math.floor((seconds % 1) * 1000);
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}`;
        }

        function updateGateCounter() {
            document.getElementById('gate-counter').textContent =
                `Gate ${gameState.currentGate} / ${gameState.totalGates}`;
        }

        function updateBestLap() {
            const bestLapEl = document.getElementById('best-lap');
            bestLapEl.textContent = gameState.bestLap ? formatTime(gameState.bestLap) : '--:--';
        }

        // --- 13. BETAFLIGHT ACTUAL RATES ---
        function calculateActualRate(input, centerSens, maxRate, expo) {
            const deflection = Math.abs(input);
            if (deflection < 0.02) return 0;

            const s = centerSens;
            const m = maxRate;
            const e = expo;

            const curve = Math.pow(deflection, 1 + (e * 3));
            const rateMag = s + (m - s) * curve;

            return (deflection * rateMag) * Math.sign(input);
        }

        // --- 14. PHYSICS UPDATE ---
        function updatePhysics(dt, rawRoll, rawPitch, rawYaw, rawThrottle) {
            if (physics.crashed) return;

            // Clamp dt to prevent explosion on tab switch
            dt = Math.min(dt, 0.05);

            // Get rate values from UI
            const rC = parseFloat(document.getElementById('roll-center').value);
            const rM = parseFloat(document.getElementById('roll-max').value);
            const rE = parseFloat(document.getElementById('roll-expo').value);
            const pC = parseFloat(document.getElementById('pitch-center').value);
            const pM = parseFloat(document.getElementById('pitch-max').value);
            const pE = parseFloat(document.getElementById('pitch-expo').value);
            const yC = parseFloat(document.getElementById('yaw-center').value);
            const yM = parseFloat(document.getElementById('yaw-max').value);
            const yE = parseFloat(document.getElementById('yaw-expo').value);

            // Calculate rotation rates
            const rollRate = calculateActualRate(rawRoll, rC, rM, rE);
            const pitchRate = calculateActualRate(rawPitch, pC, pM, pE);
            const yawRate = calculateActualRate(rawYaw, yC, yM, yE);

            // Apply rotations (in drone's local frame)
            droneGroup.rotateX(THREE.MathUtils.degToRad(pitchRate * dt));
            droneGroup.rotateY(THREE.MathUtils.degToRad(yawRate * dt));
            droneGroup.rotateZ(THREE.MathUtils.degToRad(-rollRate * dt));

            // Calculate thrust (throttle 0-1 mapped from -1 to 1 input)
            const throttle01 = (rawThrottle + 1) / 2;
            const thrustMagnitude = throttle01 * physics.maxThrust;

            // Get drone's up vector (local Y in world space)
            const thrustDir = new THREE.Vector3(0, 1, 0);
            thrustDir.applyQuaternion(droneGroup.quaternion);

            // Apply thrust
            const thrust = thrustDir.multiplyScalar(thrustMagnitude);

            // Acceleration = thrust/mass - gravity
            const acceleration = new THREE.Vector3(
                thrust.x,
                thrust.y - physics.gravity,
                thrust.z
            );

            // Update velocity
            physics.velocity.add(acceleration.multiplyScalar(dt));

            // Apply drag
            const dragFactor = 1 - physics.dragCoeff * dt;
            physics.velocity.multiplyScalar(dragFactor);

            // Update position
            physics.position.add(physics.velocity.clone().multiplyScalar(dt));

            // Bounds check
            const bound = groundSize / 2 - 10;
            physics.position.x = THREE.MathUtils.clamp(physics.position.x, -bound, bound);
            physics.position.z = THREE.MathUtils.clamp(physics.position.z, -bound, bound);
            physics.position.y = Math.max(physics.position.y, physics.droneRadius);

            // Sync drone group position
            droneGroup.position.copy(physics.position);

            // Check collisions
            if (checkGroundCollision()) {
                triggerCrash();
                return;
            }

            if (checkGateCollision()) {
                triggerCrash();
                return;
            }

            if (checkTreeCollision()) {
                triggerCrash();
                return;
            }

            if (checkBuildingCollision()) {
                triggerCrash();
                return;
            }

            if (checkTrainCollision()) {
                triggerCrash();
                return;
            }

            checkGatePass();
        }

        // --- 15. CAMERA UPDATE ---
        // Pre-calculate the 180Â° flip quaternion (cameras look down -Z, drone forward is +Z)
        const cameraFlipQuat = new THREE.Quaternion();
        cameraFlipQuat.setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI);

        function updateCamera(dt) {
            // FPV camera rigidly attached to front of drone body

            // Camera position in drone's local space (front of drone, between front props)
            const localOffset = cameraController.offset.clone();
            localOffset.applyQuaternion(droneGroup.quaternion);
            const camPos = physics.position.clone().add(localOffset);

            // Set camera position
            camera.position.copy(camPos);

            // Start with drone's rotation
            camera.quaternion.copy(droneGroup.quaternion);

            // Flip camera 180Â° around Y so it looks forward (+Z) instead of backward (-Z)
            camera.quaternion.multiply(cameraFlipQuat);

            // Apply camera tilt (rotation around local X axis)
            const tiltQuat = new THREE.Quaternion();
            tiltQuat.setFromAxisAngle(new THREE.Vector3(1, 0, 0), THREE.MathUtils.degToRad(cameraController.tiltAngle));
            camera.quaternion.multiply(tiltQuat);
        }

        // --- 16. HUD UPDATE ---
        function updateHUD(throttle01) {
            const speed = physics.velocity.length();
            const alt = physics.position.y;

            document.getElementById('hud-speed').textContent = speed.toFixed(1);
            document.getElementById('hud-alt').textContent = alt.toFixed(1);
            document.getElementById('hud-throttle').textContent = Math.round(throttle01 * 100);
            document.getElementById('hud-tilt').textContent = cameraController.tiltAngle;

            if (gameState.mode === 'racing') {
                const elapsed = (performance.now() - gameState.raceStartTime) / 1000;
                document.getElementById('race-time').textContent = formatTime(elapsed);
            }
        }

        // --- 17. PROP ANIMATION ---
        function animateProps(throttle01) {
            const spinSpeed = throttle01 * 50;
            propellers.forEach((prop, i) => {
                prop.rotation.y += spinSpeed * (i % 2 === 0 ? 1 : -1) * 0.1;
            });
        }

        // --- 18. INPUT HANDLING ---
        let activeGamepadIndex = null;

        window.addEventListener("gamepadconnected", (e) => {
            activeGamepadIndex = e.gamepad.index;
            showNotification(`Connected: ${e.gamepad.id}`);
        });
        window.addEventListener("gamepaddisconnected", () => {
            activeGamepadIndex = null;
            showNotification("Controller disconnected");
        });

        // Keyboard controls
        window.addEventListener('keydown', (e) => {
            if (e.code === 'KeyR') {
                resetDrone();
            } else if (e.code === 'Space' || e.code === 'Enter') {
                if (gameState.mode === 'freefly') {
                    startRace();
                }
            } else if (e.code === 'Escape') {
                if (gameState.mode === 'racing') {
                    gameState.mode = 'freefly';
                    document.getElementById('race-info').style.display = 'none';
                    showNotification('Race cancelled');
                }
            } else if (e.code === 'KeyW') {
                // Tilt camera up
                cameraController.tiltAngle = Math.min(
                    cameraController.maxTilt,
                    cameraController.tiltAngle + 5
                );
                showNotification(`Camera tilt: ${cameraController.tiltAngle}Â°`);
            } else if (e.code === 'KeyS') {
                // Tilt camera down
                cameraController.tiltAngle = Math.max(
                    cameraController.minTilt,
                    cameraController.tiltAngle - 5
                );
                showNotification(`Camera tilt: ${cameraController.tiltAngle}Â°`);
            }
        });

        // Mode buttons
        document.getElementById('mode-freefly').addEventListener('click', () => {
            document.getElementById('mode-freefly').classList.add('active');
            document.getElementById('mode-race').classList.remove('active');
            if (gameState.mode === 'racing') {
                gameState.mode = 'freefly';
                document.getElementById('race-info').style.display = 'none';
            }
        });

        document.getElementById('mode-race').addEventListener('click', () => {
            document.getElementById('mode-race').classList.add('active');
            document.getElementById('mode-freefly').classList.remove('active');
            startRace();
        });

        // Reset button
        document.getElementById('reset-cam').addEventListener('click', resetDrone);

        // --- 19. CONTROLLER MAPPING UI ---
        const modal = document.getElementById('mapping-modal');
        const rowsContainer = document.getElementById('mapping-rows');
        const functions = ['Roll', 'Pitch', 'Yaw', 'Throttle'];

        document.getElementById('open-mapping').addEventListener('click', () => {
            if (activeGamepadIndex === null) {
                showNotification("Connect controller first!");
                return;
            }
            renderMappingUI();
            modal.style.display = 'flex';
        });

        document.getElementById('close-mapping').addEventListener('click', () => {
            modal.style.display = 'none';
            saveConfig();
            showNotification("Mapping saved");
        });

        function renderMappingUI() {
            rowsContainer.innerHTML = '';

            functions.forEach(func => {
                const key = func.toLowerCase();
                const setting = config.mapping[key];

                const row = document.createElement('div');
                row.className = 'map-row';

                const label = document.createElement('div');
                label.className = 'map-label';
                label.innerText = func;

                const select = document.createElement('select');
                select.className = 'map-select';
                for (let i = 0; i < 8; i++) {
                    const opt = document.createElement('option');
                    opt.value = i;
                    opt.innerText = `Axis ${i}`;
                    if (i === setting.axis) opt.selected = true;
                    select.appendChild(opt);
                }
                select.onchange = (e) => config.mapping[key].axis = parseInt(e.target.value);

                const invertDiv = document.createElement('div');
                invertDiv.className = 'map-invert';
                const chk = document.createElement('input');
                chk.type = 'checkbox';
                chk.checked = setting.invert;
                chk.onchange = (e) => config.mapping[key].invert = e.target.checked;
                invertDiv.appendChild(chk);
                invertDiv.appendChild(document.createTextNode('Inv'));

                const viz = document.createElement('div');
                viz.className = 'axis-viz';
                const bar = document.createElement('div');
                bar.className = 'axis-bar';
                bar.id = `viz-${key}`;
                viz.appendChild(bar);

                row.appendChild(label);
                row.appendChild(select);
                row.appendChild(invertDiv);
                row.appendChild(viz);
                rowsContainer.appendChild(row);
            });
        }

        // --- 20. WINDOW RESIZE ---
        window.addEventListener('resize', () => {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });

        // --- 21. MAIN ANIMATION LOOP ---
        const clock = new THREE.Clock();
        updateBestLap();

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();

            let rawRoll = 0, rawPitch = 0, rawYaw = 0, rawThrottle = -1;

            if (activeGamepadIndex !== null) {
                const gp = navigator.getGamepads()[activeGamepadIndex];
                if (gp) {
                    const getAxisVal = (name) => {
                        const map = config.mapping[name];
                        let val = gp.axes[map.axis] || 0;
                        if (map.invert) val *= -1;
                        return val;
                    };

                    rawRoll = getAxisVal('roll');
                    rawPitch = getAxisVal('pitch');
                    rawYaw = getAxisVal('yaw');
                    rawThrottle = getAxisVal('throttle');

                    // Update mapping visualizers if modal is open
                    if (modal.style.display === 'flex') {
                        const updateViz = (name, val) => {
                            const bar = document.getElementById(`viz-${name}`);
                            if (bar) {
                                const pct = (val + 1) * 50;
                                bar.style.left = val < 0 ? `${pct}%` : '50%';
                                bar.style.width = `${Math.abs(val) * 50}%`;
                            }
                        };
                        updateViz('roll', rawRoll);
                        updateViz('pitch', rawPitch);
                        updateViz('yaw', rawYaw);
                        updateViz('throttle', rawThrottle);
                    }
                }
            }

            // Update systems
            if (gameState.mode !== 'countdown') {
                updatePhysics(dt, rawRoll, rawPitch, rawYaw, rawThrottle);
            }
            updateCamera(dt);

            const throttle01 = (rawThrottle + 1) / 2;
            updateHUD(throttle01);
            animateProps(throttle01);
            updateClouds(dt);
            updateTrain(dt);

            renderer.render(scene, camera);
        }

        animate();

    </script>
</body>
</html>
